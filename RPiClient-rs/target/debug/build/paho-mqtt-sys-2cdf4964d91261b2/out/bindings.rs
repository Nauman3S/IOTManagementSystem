/* automatically generated by rust-bindgen 0.59.1 */

pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_LIBIO_H: u32 = 1;
pub const _BITS_G_CONFIG_H: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const MQTT_INVALID_PROPERTY_ID: i32 = -2;
pub const MQTTCLIENT_PERSISTENCE_DEFAULT: u32 = 0;
pub const MQTTCLIENT_PERSISTENCE_NONE: u32 = 1;
pub const MQTTCLIENT_PERSISTENCE_USER: u32 = 2;
pub const MQTTCLIENT_PERSISTENCE_ERROR: i32 = -2;
pub const MQTTASYNC_SUCCESS: u32 = 0;
pub const MQTTASYNC_FAILURE: i32 = -1;
pub const MQTTASYNC_PERSISTENCE_ERROR: i32 = -2;
pub const MQTTASYNC_DISCONNECTED: i32 = -3;
pub const MQTTASYNC_MAX_MESSAGES_INFLIGHT: i32 = -4;
pub const MQTTASYNC_BAD_UTF8_STRING: i32 = -5;
pub const MQTTASYNC_NULL_PARAMETER: i32 = -6;
pub const MQTTASYNC_TOPICNAME_TRUNCATED: i32 = -7;
pub const MQTTASYNC_BAD_STRUCTURE: i32 = -8;
pub const MQTTASYNC_BAD_QOS: i32 = -9;
pub const MQTTASYNC_NO_MORE_MSGIDS: i32 = -10;
pub const MQTTASYNC_OPERATION_INCOMPLETE: i32 = -11;
pub const MQTTASYNC_MAX_BUFFERED_MESSAGES: i32 = -12;
pub const MQTTASYNC_SSL_NOT_SUPPORTED: i32 = -13;
pub const MQTTASYNC_BAD_PROTOCOL: i32 = -14;
pub const MQTTASYNC_BAD_MQTT_OPTION: i32 = -15;
pub const MQTTASYNC_WRONG_MQTT_VERSION: i32 = -16;
pub const MQTTASYNC_0_LEN_WILL_TOPIC: i32 = -17;
pub const MQTTASYNC_COMMAND_IGNORED: i32 = -18;
pub const MQTTASYNC_MAX_BUFFERED: i32 = -19;
pub const MQTTVERSION_DEFAULT: u32 = 0;
pub const MQTTVERSION_3_1: u32 = 3;
pub const MQTTVERSION_3_1_1: u32 = 4;
pub const MQTTVERSION_5: u32 = 5;
pub const MQTT_BAD_SUBSCRIBE: u32 = 128;
pub const MQTT_SSL_VERSION_DEFAULT: u32 = 0;
pub const MQTT_SSL_VERSION_TLS_1_0: u32 = 1;
pub const MQTT_SSL_VERSION_TLS_1_1: u32 = 2;
pub const MQTT_SSL_VERSION_TLS_1_2: u32 = 3;
pub const MQTTASYNC_TRUE: u32 = 1;
pub type size_t = ::std::os::raw::c_ulong;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: size_t,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(
        arg1: *mut _IO_FILE,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
#[doc = "< The value is 1"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_PAYLOAD_FORMAT_INDICATOR: MQTTPropertyCodes = 1;
#[doc = "< The value is 2"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_MESSAGE_EXPIRY_INTERVAL: MQTTPropertyCodes = 2;
#[doc = "< The value is 3"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_CONTENT_TYPE: MQTTPropertyCodes = 3;
#[doc = "< The value is 8"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_RESPONSE_TOPIC: MQTTPropertyCodes = 8;
#[doc = "< The value is 9"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_CORRELATION_DATA: MQTTPropertyCodes = 9;
#[doc = "< The value is 11"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_SUBSCRIPTION_IDENTIFIER: MQTTPropertyCodes = 11;
#[doc = "< The value is 17"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_SESSION_EXPIRY_INTERVAL: MQTTPropertyCodes = 17;
#[doc = "< The value is 18"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_ASSIGNED_CLIENT_IDENTIFER: MQTTPropertyCodes = 18;
#[doc = "< The value is 19"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_SERVER_KEEP_ALIVE: MQTTPropertyCodes = 19;
#[doc = "< The value is 21"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_AUTHENTICATION_METHOD: MQTTPropertyCodes = 21;
#[doc = "< The value is 22"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_AUTHENTICATION_DATA: MQTTPropertyCodes = 22;
#[doc = "< The value is 23"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_REQUEST_PROBLEM_INFORMATION: MQTTPropertyCodes = 23;
#[doc = "< The value is 24"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_WILL_DELAY_INTERVAL: MQTTPropertyCodes = 24;
#[doc = "< The value is 25"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_REQUEST_RESPONSE_INFORMATION: MQTTPropertyCodes = 25;
#[doc = "< The value is 26"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_RESPONSE_INFORMATION: MQTTPropertyCodes = 26;
#[doc = "< The value is 28"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_SERVER_REFERENCE: MQTTPropertyCodes = 28;
#[doc = "< The value is 31"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_REASON_STRING: MQTTPropertyCodes = 31;
#[doc = "< The value is 33"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_RECEIVE_MAXIMUM: MQTTPropertyCodes = 33;
#[doc = "< The value is 34"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_TOPIC_ALIAS_MAXIMUM: MQTTPropertyCodes = 34;
#[doc = "< The value is 35"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_TOPIC_ALIAS: MQTTPropertyCodes = 35;
#[doc = "< The value is 36"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_MAXIMUM_QOS: MQTTPropertyCodes = 36;
#[doc = "< The value is 37"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_RETAIN_AVAILABLE: MQTTPropertyCodes = 37;
#[doc = "< The value is 38"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_USER_PROPERTY: MQTTPropertyCodes = 38;
#[doc = "< The value is 39"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_MAXIMUM_PACKET_SIZE: MQTTPropertyCodes = 39;
#[doc = "< The value is 40"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_WILDCARD_SUBSCRIPTION_AVAILABLE: MQTTPropertyCodes =
    40;
#[doc = "< The value is 41"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_SUBSCRIPTION_IDENTIFIERS_AVAILABLE:
    MQTTPropertyCodes = 41;
#[doc = "< The value is 241"]
pub const MQTTPropertyCodes_MQTTPROPERTY_CODE_SHARED_SUBSCRIPTION_AVAILABLE: MQTTPropertyCodes = 42;
#[doc = " The one byte MQTT V5 property indicator"]
pub type MQTTPropertyCodes = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns a printable string description of an MQTT V5 property code."]
    #[doc = " @param value an MQTT V5 property code."]
    #[doc = " @return the printable string description of the input property code."]
    #[doc = " NULL if the code was not found."]
    pub fn MQTTPropertyName(value: MQTTPropertyCodes) -> *const ::std::os::raw::c_char;
}
pub const MQTTPropertyTypes_MQTTPROPERTY_TYPE_BYTE: MQTTPropertyTypes = 0;
pub const MQTTPropertyTypes_MQTTPROPERTY_TYPE_TWO_BYTE_INTEGER: MQTTPropertyTypes = 1;
pub const MQTTPropertyTypes_MQTTPROPERTY_TYPE_FOUR_BYTE_INTEGER: MQTTPropertyTypes = 2;
pub const MQTTPropertyTypes_MQTTPROPERTY_TYPE_VARIABLE_BYTE_INTEGER: MQTTPropertyTypes = 3;
pub const MQTTPropertyTypes_MQTTPROPERTY_TYPE_BINARY_DATA: MQTTPropertyTypes = 4;
pub const MQTTPropertyTypes_MQTTPROPERTY_TYPE_UTF_8_ENCODED_STRING: MQTTPropertyTypes = 5;
pub const MQTTPropertyTypes_MQTTPROPERTY_TYPE_UTF_8_STRING_PAIR: MQTTPropertyTypes = 6;
#[doc = " The one byte MQTT V5 property type"]
pub type MQTTPropertyTypes = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns the MQTT V5 type code of an MQTT V5 property."]
    #[doc = " @param value an MQTT V5 property code."]
    #[doc = " @return the MQTT V5 type code of the input property. -1 if the code was not found."]
    pub fn MQTTProperty_getType(value: MQTTPropertyCodes) -> ::std::os::raw::c_int;
}
#[doc = " The data for a length delimited string"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTLenString {
    #[doc = "< the length of the string"]
    pub len: ::std::os::raw::c_int,
    #[doc = "< pointer to the string data"]
    pub data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_MQTTLenString() {
    assert_eq!(
        ::std::mem::size_of::<MQTTLenString>(),
        16usize,
        concat!("Size of: ", stringify!(MQTTLenString))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTLenString>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTLenString))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTLenString>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTLenString),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTLenString>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTLenString),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Structure to hold an MQTT version 5 property of any type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MQTTProperty {
    #[doc = "<  The MQTT V5 property id. A multi-byte integer."]
    pub identifier: MQTTPropertyCodes,
    pub value: MQTTProperty__bindgen_ty_1,
}
#[doc = " The value of the property, as a union of the different possible types."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union MQTTProperty__bindgen_ty_1 {
    #[doc = "< holds the value of a byte property type"]
    pub byte: ::std::os::raw::c_uchar,
    #[doc = "< holds the value of a 2 byte integer property type"]
    pub integer2: ::std::os::raw::c_ushort,
    #[doc = "< holds the value of a 4 byte integer property type"]
    pub integer4: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: MQTTProperty__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTProperty__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The value of a string property, or the name of a user property."]
    pub data: MQTTLenString,
    #[doc = "< The value of a user property."]
    pub value: MQTTLenString,
}
#[test]
fn bindgen_test_layout_MQTTProperty__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MQTTProperty__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(MQTTProperty__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTProperty__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTProperty__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTProperty__bindgen_ty_1__bindgen_ty_1>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTProperty__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTProperty__bindgen_ty_1__bindgen_ty_1>())).value as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTProperty__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[test]
fn bindgen_test_layout_MQTTProperty__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MQTTProperty__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(MQTTProperty__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTProperty__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTProperty__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTProperty__bindgen_ty_1>())).byte as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTProperty__bindgen_ty_1),
            "::",
            stringify!(byte)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTProperty__bindgen_ty_1>())).integer2 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTProperty__bindgen_ty_1),
            "::",
            stringify!(integer2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTProperty__bindgen_ty_1>())).integer4 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTProperty__bindgen_ty_1),
            "::",
            stringify!(integer4)
        )
    );
}
#[test]
fn bindgen_test_layout_MQTTProperty() {
    assert_eq!(
        ::std::mem::size_of::<MQTTProperty>(),
        40usize,
        concat!("Size of: ", stringify!(MQTTProperty))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTProperty>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTProperty))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTProperty>())).identifier as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTProperty),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTProperty>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTProperty),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " MQTT version 5 property list"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTProperties {
    #[doc = "< number of property entries in the array"]
    pub count: ::std::os::raw::c_int,
    #[doc = "< max number of properties that the currently allocated array can store"]
    pub max_count: ::std::os::raw::c_int,
    #[doc = "< mbi: byte length of all properties"]
    pub length: ::std::os::raw::c_int,
    #[doc = "< array of properties"]
    pub array: *mut MQTTProperty,
}
#[test]
fn bindgen_test_layout_MQTTProperties() {
    assert_eq!(
        ::std::mem::size_of::<MQTTProperties>(),
        24usize,
        concat!("Size of: ", stringify!(MQTTProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTProperties))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTProperties>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTProperties),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTProperties>())).max_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTProperties),
            "::",
            stringify!(max_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTProperties>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTProperties),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTProperties>())).array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTProperties),
            "::",
            stringify!(array)
        )
    );
}
extern "C" {
    #[doc = " Returns the length of the properties structure when serialized ready for network transmission."]
    #[doc = " @param props an MQTT V5 property structure."]
    #[doc = " @return the length in bytes of the properties when serialized."]
    pub fn MQTTProperties_len(props: *mut MQTTProperties) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a property pointer to the property array.  There is no memory allocation."]
    #[doc = " @param props The property list to add the property to."]
    #[doc = " @param prop The property to add to the list."]
    #[doc = " @return 0 on success, -1 on failure."]
    pub fn MQTTProperties_add(
        props: *mut MQTTProperties,
        prop: *const MQTTProperty,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize the given property list to a character buffer, e.g. for writing to the network."]
    #[doc = " @param pptr pointer to the buffer - move the pointer as we add data"]
    #[doc = " @param properties pointer to the property list, can be NULL"]
    #[doc = " @return whether the write succeeded or not: number of bytes written, or < 0 on failure."]
    pub fn MQTTProperties_write(
        pptr: *mut *mut ::std::os::raw::c_char,
        properties: *const MQTTProperties,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reads a property list from a character buffer into an array."]
    #[doc = " @param properties pointer to the property list to be filled. Should be initalized but empty."]
    #[doc = " @param pptr pointer to the character buffer."]
    #[doc = " @param enddata pointer to the end of the character buffer so we don't read beyond."]
    #[doc = " @return 1 if the properties were read successfully."]
    pub fn MQTTProperties_read(
        properties: *mut MQTTProperties,
        pptr: *mut *mut ::std::os::raw::c_char,
        enddata: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free all memory allocated to the property list, including any to individual properties."]
    #[doc = " @param properties pointer to the property list."]
    pub fn MQTTProperties_free(properties: *mut MQTTProperties);
}
extern "C" {
    #[doc = " Copy the contents of a property list, allocating additional memory if needed."]
    #[doc = " @param props pointer to the property list."]
    #[doc = " @return the duplicated property list."]
    pub fn MQTTProperties_copy(props: *const MQTTProperties) -> MQTTProperties;
}
extern "C" {
    #[doc = " Checks if property list contains a specific property."]
    #[doc = " @param props pointer to the property list."]
    #[doc = " @param propid the property id to check for."]
    #[doc = " @return 1 if found, 0 if not."]
    pub fn MQTTProperties_hasProperty(
        props: *mut MQTTProperties,
        propid: MQTTPropertyCodes,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of instances of a property id. Most properties can exist only once."]
    #[doc = " User properties and subscription ids can exist more than once."]
    #[doc = " @param props pointer to the property list."]
    #[doc = " @param propid the property id to check for."]
    #[doc = " @return the number of times found.  Can be 0."]
    pub fn MQTTProperties_propertyCount(
        props: *mut MQTTProperties,
        propid: MQTTPropertyCodes,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the integer value of a specific property.  The property given must be a numeric type."]
    #[doc = " @param props pointer to the property list."]
    #[doc = " @param propid the property id to check for."]
    #[doc = " @return the integer value of the property. -9999999 on failure."]
    pub fn MQTTProperties_getNumericValue(
        props: *mut MQTTProperties,
        propid: MQTTPropertyCodes,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the integer value of a specific property when it's not the only instance."]
    #[doc = " The property given must be a numeric type."]
    #[doc = " @param props pointer to the property list."]
    #[doc = " @param propid the property id to check for."]
    #[doc = " @param index the instance number, starting at 0."]
    #[doc = " @return the integer value of the property. -9999999 on failure."]
    pub fn MQTTProperties_getNumericValueAt(
        props: *mut MQTTProperties,
        propid: MQTTPropertyCodes,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns a pointer to the property structure for a specific property."]
    #[doc = " @param props pointer to the property list."]
    #[doc = " @param propid the property id to check for."]
    #[doc = " @return the pointer to the property structure if found.  NULL if not found."]
    pub fn MQTTProperties_getProperty(
        props: *mut MQTTProperties,
        propid: MQTTPropertyCodes,
    ) -> *mut MQTTProperty;
}
extern "C" {
    #[doc = " Returns a pointer to the property structure for a specific property when it's not the only instance."]
    #[doc = " @param props pointer to the property list."]
    #[doc = " @param propid the property id to check for."]
    #[doc = " @param index the instance number, starting at 0."]
    #[doc = " @return the pointer to the property structure if found.  NULL if not found."]
    pub fn MQTTProperties_getPropertyAt(
        props: *mut MQTTProperties,
        propid: MQTTPropertyCodes,
        index: ::std::os::raw::c_int,
    ) -> *mut MQTTProperty;
}
pub const MQTTReasonCodes_MQTTREASONCODE_SUCCESS: MQTTReasonCodes = 0;
pub const MQTTReasonCodes_MQTTREASONCODE_NORMAL_DISCONNECTION: MQTTReasonCodes = 0;
pub const MQTTReasonCodes_MQTTREASONCODE_GRANTED_QOS_0: MQTTReasonCodes = 0;
pub const MQTTReasonCodes_MQTTREASONCODE_GRANTED_QOS_1: MQTTReasonCodes = 1;
pub const MQTTReasonCodes_MQTTREASONCODE_GRANTED_QOS_2: MQTTReasonCodes = 2;
pub const MQTTReasonCodes_MQTTREASONCODE_DISCONNECT_WITH_WILL_MESSAGE: MQTTReasonCodes = 4;
pub const MQTTReasonCodes_MQTTREASONCODE_NO_MATCHING_SUBSCRIBERS: MQTTReasonCodes = 16;
pub const MQTTReasonCodes_MQTTREASONCODE_NO_SUBSCRIPTION_FOUND: MQTTReasonCodes = 17;
pub const MQTTReasonCodes_MQTTREASONCODE_CONTINUE_AUTHENTICATION: MQTTReasonCodes = 24;
pub const MQTTReasonCodes_MQTTREASONCODE_RE_AUTHENTICATE: MQTTReasonCodes = 25;
pub const MQTTReasonCodes_MQTTREASONCODE_UNSPECIFIED_ERROR: MQTTReasonCodes = 128;
pub const MQTTReasonCodes_MQTTREASONCODE_MALFORMED_PACKET: MQTTReasonCodes = 129;
pub const MQTTReasonCodes_MQTTREASONCODE_PROTOCOL_ERROR: MQTTReasonCodes = 130;
pub const MQTTReasonCodes_MQTTREASONCODE_IMPLEMENTATION_SPECIFIC_ERROR: MQTTReasonCodes = 131;
pub const MQTTReasonCodes_MQTTREASONCODE_UNSUPPORTED_PROTOCOL_VERSION: MQTTReasonCodes = 132;
pub const MQTTReasonCodes_MQTTREASONCODE_CLIENT_IDENTIFIER_NOT_VALID: MQTTReasonCodes = 133;
pub const MQTTReasonCodes_MQTTREASONCODE_BAD_USER_NAME_OR_PASSWORD: MQTTReasonCodes = 134;
pub const MQTTReasonCodes_MQTTREASONCODE_NOT_AUTHORIZED: MQTTReasonCodes = 135;
pub const MQTTReasonCodes_MQTTREASONCODE_SERVER_UNAVAILABLE: MQTTReasonCodes = 136;
pub const MQTTReasonCodes_MQTTREASONCODE_SERVER_BUSY: MQTTReasonCodes = 137;
pub const MQTTReasonCodes_MQTTREASONCODE_BANNED: MQTTReasonCodes = 138;
pub const MQTTReasonCodes_MQTTREASONCODE_SERVER_SHUTTING_DOWN: MQTTReasonCodes = 139;
pub const MQTTReasonCodes_MQTTREASONCODE_BAD_AUTHENTICATION_METHOD: MQTTReasonCodes = 140;
pub const MQTTReasonCodes_MQTTREASONCODE_KEEP_ALIVE_TIMEOUT: MQTTReasonCodes = 141;
pub const MQTTReasonCodes_MQTTREASONCODE_SESSION_TAKEN_OVER: MQTTReasonCodes = 142;
pub const MQTTReasonCodes_MQTTREASONCODE_TOPIC_FILTER_INVALID: MQTTReasonCodes = 143;
pub const MQTTReasonCodes_MQTTREASONCODE_TOPIC_NAME_INVALID: MQTTReasonCodes = 144;
pub const MQTTReasonCodes_MQTTREASONCODE_PACKET_IDENTIFIER_IN_USE: MQTTReasonCodes = 145;
pub const MQTTReasonCodes_MQTTREASONCODE_PACKET_IDENTIFIER_NOT_FOUND: MQTTReasonCodes = 146;
pub const MQTTReasonCodes_MQTTREASONCODE_RECEIVE_MAXIMUM_EXCEEDED: MQTTReasonCodes = 147;
pub const MQTTReasonCodes_MQTTREASONCODE_TOPIC_ALIAS_INVALID: MQTTReasonCodes = 148;
pub const MQTTReasonCodes_MQTTREASONCODE_PACKET_TOO_LARGE: MQTTReasonCodes = 149;
pub const MQTTReasonCodes_MQTTREASONCODE_MESSAGE_RATE_TOO_HIGH: MQTTReasonCodes = 150;
pub const MQTTReasonCodes_MQTTREASONCODE_QUOTA_EXCEEDED: MQTTReasonCodes = 151;
pub const MQTTReasonCodes_MQTTREASONCODE_ADMINISTRATIVE_ACTION: MQTTReasonCodes = 152;
pub const MQTTReasonCodes_MQTTREASONCODE_PAYLOAD_FORMAT_INVALID: MQTTReasonCodes = 153;
pub const MQTTReasonCodes_MQTTREASONCODE_RETAIN_NOT_SUPPORTED: MQTTReasonCodes = 154;
pub const MQTTReasonCodes_MQTTREASONCODE_QOS_NOT_SUPPORTED: MQTTReasonCodes = 155;
pub const MQTTReasonCodes_MQTTREASONCODE_USE_ANOTHER_SERVER: MQTTReasonCodes = 156;
pub const MQTTReasonCodes_MQTTREASONCODE_SERVER_MOVED: MQTTReasonCodes = 157;
pub const MQTTReasonCodes_MQTTREASONCODE_SHARED_SUBSCRIPTIONS_NOT_SUPPORTED: MQTTReasonCodes = 158;
pub const MQTTReasonCodes_MQTTREASONCODE_CONNECTION_RATE_EXCEEDED: MQTTReasonCodes = 159;
pub const MQTTReasonCodes_MQTTREASONCODE_MAXIMUM_CONNECT_TIME: MQTTReasonCodes = 160;
pub const MQTTReasonCodes_MQTTREASONCODE_SUBSCRIPTION_IDENTIFIERS_NOT_SUPPORTED: MQTTReasonCodes =
    161;
pub const MQTTReasonCodes_MQTTREASONCODE_WILDCARD_SUBSCRIPTIONS_NOT_SUPPORTED: MQTTReasonCodes =
    162;
#[doc = " The MQTT V5 one byte reason code"]
pub type MQTTReasonCodes = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns a printable string description of an MQTT V5 reason code."]
    #[doc = " @param value an MQTT V5 reason code."]
    #[doc = " @return the printable string description of the input reason code."]
    #[doc = " NULL if the code was not found."]
    pub fn MQTTReasonCode_toString(value: MQTTReasonCodes) -> *const ::std::os::raw::c_char;
}
#[doc = " The MQTT V5 subscribe options, apart from QoS which existed before V5."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTSubscribe_options {
    #[doc = " The eyecatcher for this structure. Must be MQSO."]
    pub struct_id: [::std::os::raw::c_char; 4usize],
    #[doc = " The version number of this structure.  Must be 0."]
    pub struct_version: ::std::os::raw::c_int,
    #[doc = " To not receive our own publications, set to 1."]
    #[doc = "  0 is the original MQTT behaviour - all messages matching the subscription are received."]
    pub noLocal: ::std::os::raw::c_uchar,
    #[doc = " To keep the retain flag as on the original publish message, set to 1."]
    #[doc = "  If 0, defaults to the original MQTT behaviour where the retain flag is only set on"]
    #[doc = "  publications sent by a broker if in response to a subscribe request."]
    pub retainAsPublished: ::std::os::raw::c_uchar,
    #[doc = " 0 - send retained messages at the time of the subscribe (original MQTT behaviour)"]
    #[doc = "  1 - send retained messages on subscribe only if the subscription is new"]
    #[doc = "  2 - do not send retained messages at all"]
    pub retainHandling: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_MQTTSubscribe_options() {
    assert_eq!(
        ::std::mem::size_of::<MQTTSubscribe_options>(),
        12usize,
        concat!("Size of: ", stringify!(MQTTSubscribe_options))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTSubscribe_options>(),
        4usize,
        concat!("Alignment of ", stringify!(MQTTSubscribe_options))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTSubscribe_options>())).struct_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTSubscribe_options),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTSubscribe_options>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTSubscribe_options),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTSubscribe_options>())).noLocal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTSubscribe_options),
            "::",
            stringify!(noLocal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTSubscribe_options>())).retainAsPublished as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTSubscribe_options),
            "::",
            stringify!(retainAsPublished)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTSubscribe_options>())).retainHandling as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTSubscribe_options),
            "::",
            stringify!(retainHandling)
        )
    );
}
#[doc = " @brief Initialize the persistent store."]
#[doc = ""]
#[doc = " Either open the existing persistent store for this client ID or create a new"]
#[doc = " one if one doesn't exist. If the persistent store is already open, return"]
#[doc = " without taking any action."]
#[doc = ""]
#[doc = " An application can use the same client identifier to connect to many"]
#[doc = " different servers. The <i>clientid</i> in conjunction with the"]
#[doc = " <i>serverURI</i> uniquely identifies the persistence store required."]
#[doc = ""]
#[doc = " @param handle The address of a pointer to a handle for this persistence"]
#[doc = " implementation. This function must set handle to a valid reference to the"]
#[doc = " persistence following a successful return."]
#[doc = " The handle pointer is passed as an argument to all the other"]
#[doc = " persistence functions. It may include the context parameter and/or any other"]
#[doc = " data for use by the persistence functions."]
#[doc = " @param clientID The client identifier for which the persistent store should"]
#[doc = " be opened."]
#[doc = " @param serverURI The connection string specified when the MQTT client was"]
#[doc = " created (see MQTTClient_create())."]
#[doc = " @param context A pointer to any data required to initialize the persistent"]
#[doc = " store (see ::MQTTClient_persistence)."]
#[doc = " @return Return 0 if the function completes successfully, otherwise return"]
#[doc = " ::MQTTCLIENT_PERSISTENCE_ERROR."]
pub type Persistence_open = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut *mut ::std::os::raw::c_void,
        clientID: *const ::std::os::raw::c_char,
        serverURI: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @brief Close the persistent store referred to by the handle."]
#[doc = ""]
#[doc = " @param handle The handle pointer from a successful call to"]
#[doc = " Persistence_open()."]
#[doc = " @return Return 0 if the function completes successfully, otherwise return"]
#[doc = " ::MQTTCLIENT_PERSISTENCE_ERROR."]
pub type Persistence_close = ::std::option::Option<
    unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " @brief Put the specified data into the persistent store."]
#[doc = ""]
#[doc = " @param handle The handle pointer from a successful call to"]
#[doc = " Persistence_open()."]
#[doc = " @param key A string used as the key for the data to be put in the store. The"]
#[doc = " key is later used to retrieve data from the store with Persistence_get()."]
#[doc = " @param bufcount The number of buffers to write to the persistence store."]
#[doc = " @param buffers An array of pointers to the data buffers associated with"]
#[doc = " this <i>key</i>."]
#[doc = " @param buflens An array of lengths of the data buffers. <i>buflen[n]</i>"]
#[doc = " gives the length of <i>buffer[n]</i>."]
#[doc = " @return Return 0 if the function completes successfully, otherwise return"]
#[doc = " ::MQTTCLIENT_PERSISTENCE_ERROR."]
pub type Persistence_put = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_char,
        bufcount: ::std::os::raw::c_int,
        buffers: *mut *mut ::std::os::raw::c_char,
        buflens: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @brief Retrieve the specified data from the persistent store."]
#[doc = ""]
#[doc = " @param handle The handle pointer from a successful call to"]
#[doc = " Persistence_open()."]
#[doc = " @param key A string that is the key for the data to be retrieved. This is"]
#[doc = " the same key used to save the data to the store with Persistence_put()."]
#[doc = " @param buffer The address of a pointer to a buffer. This function sets the"]
#[doc = " pointer to point at the retrieved data, if successful."]
#[doc = " @param buflen The address of an int that is set to the length of"]
#[doc = " <i>buffer</i> by this function if successful."]
#[doc = " @return Return 0 if the function completes successfully, otherwise return"]
#[doc = " ::MQTTCLIENT_PERSISTENCE_ERROR."]
pub type Persistence_get = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_char,
        buffer: *mut *mut ::std::os::raw::c_char,
        buflen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @brief Remove the data for the specified key from the store."]
#[doc = ""]
#[doc = " @param handle The handle pointer from a successful call to"]
#[doc = " Persistence_open()."]
#[doc = " @param key A string that is the key for the data to be removed from the"]
#[doc = " store. This is the same key used to save the data to the store with"]
#[doc = " Persistence_put()."]
#[doc = " @return Return 0 if the function completes successfully, otherwise return"]
#[doc = " ::MQTTCLIENT_PERSISTENCE_ERROR."]
pub type Persistence_remove = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @brief Returns the keys in this persistent data store."]
#[doc = ""]
#[doc = " @param handle The handle pointer from a successful call to"]
#[doc = " Persistence_open()."]
#[doc = " @param keys The address of a pointer to pointers to strings. Assuming"]
#[doc = " successful execution, this function allocates memory to hold the returned"]
#[doc = " keys (strings used to store the data with Persistence_put()). It also"]
#[doc = " allocates memory to hold an array of pointers to these strings. <i>keys</i>"]
#[doc = " is set to point to the array of pointers to strings."]
#[doc = " @param nkeys A pointer to the number of keys in this persistent data store."]
#[doc = " This function sets the number of keys, if successful."]
#[doc = " @return Return 0 if the function completes successfully, otherwise return"]
#[doc = " ::MQTTCLIENT_PERSISTENCE_ERROR."]
pub type Persistence_keys = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::std::os::raw::c_void,
        keys: *mut *mut *mut ::std::os::raw::c_char,
        nkeys: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @brief Clears the persistence store, so that it no longer contains any"]
#[doc = " persisted data."]
#[doc = ""]
#[doc = " @param handle The handle pointer from a successful call to"]
#[doc = " Persistence_open()."]
#[doc = " @return Return 0 if the function completes successfully, otherwise return"]
#[doc = " ::MQTTCLIENT_PERSISTENCE_ERROR."]
pub type Persistence_clear = ::std::option::Option<
    unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " @brief Returns whether any data has been persisted using the specified key."]
#[doc = ""]
#[doc = " @param handle The handle pointer from a successful call to"]
#[doc = " Persistence_open()."]
#[doc = " @param key The string to be tested for existence in the store."]
#[doc = " @return Return 0 if the key was found in the store, otherwise return"]
#[doc = " ::MQTTCLIENT_PERSISTENCE_ERROR."]
pub type Persistence_containskey = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @brief A structure containing the function pointers to a persistence"]
#[doc = " implementation and the context or state that will be shared across all"]
#[doc = " the persistence functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTClient_persistence {
    #[doc = " A pointer to any data required to initialize the persistent store."]
    pub context: *mut ::std::os::raw::c_void,
    #[doc = " A function pointer to an implementation of Persistence_open()."]
    pub popen: Persistence_open,
    #[doc = " A function pointer to an implementation of Persistence_close()."]
    pub pclose: Persistence_close,
    #[doc = " A function pointer to an implementation of Persistence_put()."]
    pub pput: Persistence_put,
    #[doc = " A function pointer to an implementation of Persistence_get()."]
    pub pget: Persistence_get,
    #[doc = " A function pointer to an implementation of Persistence_remove()."]
    pub premove: Persistence_remove,
    #[doc = " A function pointer to an implementation of Persistence_keys()."]
    pub pkeys: Persistence_keys,
    #[doc = " A function pointer to an implementation of Persistence_clear()."]
    pub pclear: Persistence_clear,
    #[doc = " A function pointer to an implementation of Persistence_containskey()."]
    pub pcontainskey: Persistence_containskey,
}
#[test]
fn bindgen_test_layout_MQTTClient_persistence() {
    assert_eq!(
        ::std::mem::size_of::<MQTTClient_persistence>(),
        72usize,
        concat!("Size of: ", stringify!(MQTTClient_persistence))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTClient_persistence>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTClient_persistence))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).popen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(popen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).pclose as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(pclose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).pput as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(pput)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).pget as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(pget)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).premove as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(premove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).pkeys as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(pkeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTClient_persistence>())).pclear as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(pclear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTClient_persistence>())).pcontainskey as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTClient_persistence),
            "::",
            stringify!(pcontainskey)
        )
    );
}
#[doc = " A callback which is invoked just before a write to persistence.  This can be"]
#[doc = " used to transform the data, for instance to encrypt it."]
#[doc = " @param context The context as set in ::MQTTAsync_setBeforePersistenceWrite"]
#[doc = " @param bufcount The number of buffers to write to the persistence store."]
#[doc = " @param buffers An array of pointers to the data buffers."]
#[doc = " @param buflens An array of lengths of the data buffers."]
#[doc = " @return Return 0 if the function completes successfully, otherwise non 0."]
pub type MQTTPersistence_beforeWrite = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        bufcount: ::std::os::raw::c_int,
        buffers: *mut *mut ::std::os::raw::c_char,
        buflens: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A callback which is invoked just after a read from persistence.  This can be"]
#[doc = " used to transform the data, for instance to decrypt it."]
#[doc = " @param context The context as set in ::MQTTAsync_setAfterPersistenceRead"]
#[doc = " @param buffer The address of a pointer to a buffer."]
#[doc = " @param buflen The address of an int that is the length of the buffer."]
#[doc = " @return Return 0 if the function completes successfully, otherwise non 0."]
pub type MQTTPersistence_afterRead = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        buffer: *mut *mut ::std::os::raw::c_char,
        buflen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "  Initialization options"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_init_options {
    #[doc = " The eyecatcher for this structure.  Must be MQTG."]
    pub struct_id: [::std::os::raw::c_char; 4usize],
    #[doc = " The version number of this structure.  Must be 0"]
    pub struct_version: ::std::os::raw::c_int,
    #[doc = " 1 = we do openssl init, 0 = leave it to the application"]
    pub do_openssl_init: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MQTTAsync_init_options() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_init_options>(),
        12usize,
        concat!("Size of: ", stringify!(MQTTAsync_init_options))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_init_options>(),
        4usize,
        concat!("Alignment of ", stringify!(MQTTAsync_init_options))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_init_options>())).struct_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_init_options),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_init_options>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_init_options),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_init_options>())).do_openssl_init as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_init_options),
            "::",
            stringify!(do_openssl_init)
        )
    );
}
extern "C" {
    #[doc = " Global init of mqtt library. Call once on program start to set global behaviour."]
    #[doc = " handle_openssl_init - if mqtt library should handle openssl init (1) or rely on the caller to init it before using mqtt (0)"]
    pub fn MQTTAsync_global_init(inits: *mut MQTTAsync_init_options);
}
#[doc = " A handle representing an MQTT client. A valid client handle is available"]
#[doc = " following a successful call to MQTTAsync_create()."]
pub type MQTTAsync = *mut ::std::os::raw::c_void;
#[doc = " A value representing an MQTT message. A token is returned to the"]
#[doc = " client application when a message is published. The token can then be used to"]
#[doc = " check that the message was successfully delivered to its destination (see"]
#[doc = " MQTTAsync_publish(),"]
#[doc = " MQTTAsync_publishMessage(),"]
#[doc = " MQTTAsync_deliveryComplete(), and"]
#[doc = " MQTTAsync_getPendingTokens())."]
pub type MQTTAsync_token = ::std::os::raw::c_int;
#[doc = " A structure representing the payload and attributes of an MQTT message. The"]
#[doc = " message topic is not part of this structure (see MQTTAsync_publishMessage(),"]
#[doc = " MQTTAsync_publish(), MQTTAsync_receive(), MQTTAsync_freeMessage()"]
#[doc = " and MQTTAsync_messageArrived())."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_message {
    #[doc = " The eyecatcher for this structure.  must be MQTM."]
    pub struct_id: [::std::os::raw::c_char; 4usize],
    #[doc = " The version number of this structure.  Must be 0 or 1."]
    #[doc = "  0 indicates no message properties"]
    pub struct_version: ::std::os::raw::c_int,
    #[doc = " The length of the MQTT message payload in bytes."]
    pub payloadlen: ::std::os::raw::c_int,
    #[doc = " A pointer to the payload of the MQTT message."]
    pub payload: *mut ::std::os::raw::c_void,
    #[doc = " The quality of service (QoS) assigned to the message."]
    #[doc = " There are three levels of QoS:"]
    #[doc = " <DL>"]
    #[doc = " <DT><B>QoS0</B></DT>"]
    #[doc = " <DD>Fire and forget - the message may not be delivered</DD>"]
    #[doc = " <DT><B>QoS1</B></DT>"]
    #[doc = " <DD>At least once - the message will be delivered, but may be"]
    #[doc = " delivered more than once in some circumstances.</DD>"]
    #[doc = " <DT><B>QoS2</B></DT>"]
    #[doc = " <DD>Once and one only - the message will be delivered exactly once.</DD>"]
    #[doc = " </DL>"]
    pub qos: ::std::os::raw::c_int,
    #[doc = " The retained flag serves two purposes depending on whether the message"]
    #[doc = " it is associated with is being published or received."]
    #[doc = ""]
    #[doc = " <b>retained = true</b><br>"]
    #[doc = " For messages being published, a true setting indicates that the MQTT"]
    #[doc = " server should retain a copy of the message. The message will then be"]
    #[doc = " transmitted to new subscribers to a topic that matches the message topic."]
    #[doc = " For subscribers registering a new subscription, the flag being true"]
    #[doc = " indicates that the received message is not a new one, but one that has"]
    #[doc = " been retained by the MQTT server."]
    #[doc = ""]
    #[doc = " <b>retained = false</b> <br>"]
    #[doc = " For publishers, this indicates that this message should not be retained"]
    #[doc = " by the MQTT server. For subscribers, a false setting indicates this is"]
    #[doc = " a normal message, received as a result of it being published to the"]
    #[doc = " server."]
    pub retained: ::std::os::raw::c_int,
    #[doc = " The dup flag indicates whether or not this message is a duplicate."]
    #[doc = " It is only meaningful when receiving QoS1 messages. When true, the"]
    #[doc = " client application should take appropriate action to deal with the"]
    #[doc = " duplicate message.  This is an output parameter only."]
    pub dup: ::std::os::raw::c_int,
    #[doc = " The message identifier is reserved for internal use by the"]
    #[doc = " MQTT client and server.  It is an output parameter only - writing"]
    #[doc = " to it will serve no purpose.  It contains the MQTT message id of"]
    #[doc = " an incoming publish message."]
    pub msgid: ::std::os::raw::c_int,
    #[doc = " The MQTT V5 properties associated with the message."]
    pub properties: MQTTProperties,
}
#[test]
fn bindgen_test_layout_MQTTAsync_message() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_message>(),
        64usize,
        concat!("Size of: ", stringify!(MQTTAsync_message))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_message>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_message))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_message>())).struct_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_message>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_message>())).payloadlen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(payloadlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_message>())).payload as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_message>())).qos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(qos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_message>())).retained as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(retained)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_message>())).dup as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(dup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_message>())).msgid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(msgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_message>())).properties as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_message),
            "::",
            stringify!(properties)
        )
    );
}
#[doc = " This is a callback function. The client application"]
#[doc = " must provide an implementation of this function to enable asynchronous"]
#[doc = " receipt of messages. The function is registered with the client library by"]
#[doc = " passing it as an argument to MQTTAsync_setCallbacks(). It is"]
#[doc = " called by the client library when a new message that matches a client"]
#[doc = " subscription has been received from the server. This function is executed on"]
#[doc = " a separate thread to the one on which the client application is running."]
#[doc = ""]
#[doc = " <b>Note:</b> Neither MQTTAsync_create() nor MQTTAsync_destroy() should be"]
#[doc = " called within this callback."]
#[doc = " @param context A pointer to the <i>context</i> value originally passed to"]
#[doc = " MQTTAsync_setCallbacks(), which contains any application-specific context."]
#[doc = " @param topicName The topic associated with the received message."]
#[doc = " @param topicLen The length of the topic if there are one"]
#[doc = " more NULL characters embedded in <i>topicName</i>, otherwise <i>topicLen</i>"]
#[doc = " is 0. If <i>topicLen</i> is 0, the value returned by <i>strlen(topicName)</i>"]
#[doc = " can be trusted. If <i>topicLen</i> is greater than 0, the full topic name"]
#[doc = " can be retrieved by accessing <i>topicName</i> as a byte array of length"]
#[doc = " <i>topicLen</i>."]
#[doc = " @param message The MQTTAsync_message structure for the received message."]
#[doc = " This structure contains the message payload and attributes."]
#[doc = " @return This function must return 0 or 1 indicating whether or not"]
#[doc = " the message has been safely received by the client application. <br>"]
#[doc = " Returning 1 indicates that the message has been successfully handled."]
#[doc = " To free the message storage, ::MQTTAsync_freeMessage must be called."]
#[doc = " To free the topic name storage, ::MQTTAsync_free must be called.<br>"]
#[doc = " Returning 0 indicates that there was a problem. In this"]
#[doc = " case, the client library will reinvoke MQTTAsync_messageArrived() to"]
#[doc = " attempt to deliver the message to the application again."]
#[doc = " Do not free the message and topic storage when returning 0, otherwise"]
#[doc = " the redelivery will fail."]
pub type MQTTAsync_messageArrived = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        topicName: *mut ::std::os::raw::c_char,
        topicLen: ::std::os::raw::c_int,
        message: *mut MQTTAsync_message,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " This is a callback function. The client application"]
#[doc = " must provide an implementation of this function to enable asynchronous"]
#[doc = " notification of delivery of messages to the server. The function is"]
#[doc = " registered with the client library by passing it as an argument to MQTTAsync_setCallbacks()."]
#[doc = " It is called by the client library after the client application has"]
#[doc = " published a message to the server. It indicates that the necessary"]
#[doc = " handshaking and acknowledgements for the requested quality of service (see"]
#[doc = " MQTTAsync_message.qos) have been completed. This function is executed on a"]
#[doc = " separate thread to the one on which the client application is running."]
#[doc = ""]
#[doc = " <b>Note:</b> Neither MQTTAsync_create() nor MQTTAsync_destroy() should be"]
#[doc = " called within this callback."]
#[doc = " @param context A pointer to the <i>context</i> value originally passed to"]
#[doc = " MQTTAsync_setCallbacks(), which contains any application-specific context."]
#[doc = " @param token The ::MQTTAsync_token associated with"]
#[doc = " the published message. Applications can check that all messages have been"]
#[doc = " correctly published by matching the tokens returned from calls to"]
#[doc = " MQTTAsync_send() and MQTTAsync_sendMessage() with the tokens passed"]
#[doc = " to this callback."]
pub type MQTTAsync_deliveryComplete = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, token: MQTTAsync_token),
>;
#[doc = " This is a callback function. The client application"]
#[doc = " must provide an implementation of this function to enable asynchronous"]
#[doc = " notification of the loss of connection to the server. The function is"]
#[doc = " registered with the client library by passing it as an argument to"]
#[doc = " MQTTAsync_setCallbacks(). It is called by the client library if the client"]
#[doc = " loses its connection to the server. The client application must take"]
#[doc = " appropriate action, such as trying to reconnect or reporting the problem."]
#[doc = " This function is executed on a separate thread to the one on which the"]
#[doc = " client application is running."]
#[doc = ""]
#[doc = " <b>Note:</b> Neither MQTTAsync_create() nor MQTTAsync_destroy() should be"]
#[doc = " called within this callback."]
#[doc = " @param context A pointer to the <i>context</i> value originally passed to"]
#[doc = " MQTTAsync_setCallbacks(), which contains any application-specific context."]
#[doc = " @param cause The reason for the disconnection."]
#[doc = " Currently, <i>cause</i> is always set to NULL."]
pub type MQTTAsync_connectionLost = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, cause: *mut ::std::os::raw::c_char),
>;
#[doc = " This is a callback function, which will be called when the client"]
#[doc = " library successfully connects.  This is superfluous when the connection"]
#[doc = " is made in response to a MQTTAsync_connect call, because the onSuccess"]
#[doc = " callback can be used.  It is intended for use when automatic reconnect"]
#[doc = " is enabled, so that when a reconnection attempt succeeds in the background,"]
#[doc = " the application is notified and can take any required actions."]
#[doc = ""]
#[doc = " <b>Note:</b> Neither MQTTAsync_create() nor MQTTAsync_destroy() should be"]
#[doc = " called within this callback."]
#[doc = " @param context A pointer to the <i>context</i> value originally passed to"]
#[doc = " MQTTAsync_setCallbacks(), which contains any application-specific context."]
#[doc = " @param cause The reason for the disconnection."]
#[doc = " Currently, <i>cause</i> is always set to NULL."]
pub type MQTTAsync_connected = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, cause: *mut ::std::os::raw::c_char),
>;
#[doc = " This is a callback function, which will be called when the client"]
#[doc = " library receives a disconnect packet."]
#[doc = ""]
#[doc = " <b>Note:</b> Neither MQTTAsync_create() nor MQTTAsync_destroy() should be"]
#[doc = " called within this callback."]
#[doc = " @param context A pointer to the <i>context</i> value originally passed to"]
#[doc = " MQTTAsync_setCallbacks(), which contains any application-specific context."]
#[doc = " @param properties the properties in the disconnect packet."]
#[doc = " @param properties the reason code from the disconnect packet"]
#[doc = " Currently, <i>cause</i> is always set to NULL."]
pub type MQTTAsync_disconnected = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        properties: *mut MQTTProperties,
        reasonCode: MQTTReasonCodes,
    ),
>;
extern "C" {
    #[doc = " Sets the MQTTAsync_disconnected() callback function for a client."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = ""]
    #[doc = " <b>Note:</b> Neither MQTTAsync_create() nor MQTTAsync_destroy() should be"]
    #[doc = " called within this callback."]
    #[doc = " @param context A pointer to any application-specific context. The"]
    #[doc = " the <i>context</i> pointer is passed to each of the callback functions to"]
    #[doc = " provide access to the context information in the callback."]
    #[doc = " @param co A pointer to an MQTTAsync_connected() callback"]
    #[doc = " function.  NULL removes the callback setting."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the callbacks were correctly set,"]
    #[doc = " ::MQTTASYNC_FAILURE if an error occurred."]
    pub fn MQTTAsync_setDisconnected(
        handle: MQTTAsync,
        context: *mut ::std::os::raw::c_void,
        co: MQTTAsync_disconnected,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The connect options that can be updated before an automatic reconnect."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_connectData {
    #[doc = " The eyecatcher for this structure.  Will be MQCD."]
    pub struct_id: [::std::os::raw::c_char; 4usize],
    #[doc = " The version number of this structure.  Will be 0"]
    pub struct_version: ::std::os::raw::c_int,
    #[doc = " MQTT servers that support the MQTT v3.1 protocol provide authentication"]
    #[doc = " and authorisation by user name and password. This is the user name parameter."]
    #[doc = " Set data to NULL to remove.  To change, allocate new"]
    #[doc = " storage with ::MQTTAsync_allocate - this will then be free later by the library."]
    pub username: *const ::std::os::raw::c_char,
    pub binarypwd: MQTTAsync_connectData__bindgen_ty_1,
}
#[doc = " The password parameter of the MQTT authentication."]
#[doc = " Set data to NULL to remove.  To change, allocate new"]
#[doc = " storage with ::MQTTAsync_allocate - this will then be free later by the library."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_connectData__bindgen_ty_1 {
    #[doc = "< binary password length"]
    pub len: ::std::os::raw::c_int,
    #[doc = "< binary password data"]
    pub data: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MQTTAsync_connectData__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_connectData__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(MQTTAsync_connectData__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_connectData__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_connectData__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectData__bindgen_ty_1>())).len as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectData__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectData__bindgen_ty_1>())).data as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectData__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_MQTTAsync_connectData() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_connectData>(),
        32usize,
        concat!("Size of: ", stringify!(MQTTAsync_connectData))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_connectData>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_connectData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_connectData>())).struct_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectData),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectData>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectData),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_connectData>())).username as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectData),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_connectData>())).binarypwd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectData),
            "::",
            stringify!(binarypwd)
        )
    );
}
#[doc = " This is a callback function which will allow the client application to update the"]
#[doc = " connection data."]
#[doc = " @param data The connection data which can be modified by the application."]
#[doc = " @return Return a non-zero value to update the connect data, zero to keep the same data."]
pub type MQTTAsync_updateConnectOptions = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        data: *mut MQTTAsync_connectData,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Sets the MQTTAsync_updateConnectOptions() callback function for a client."]
    #[doc = " @param handle A valid client handle from a successful call to MQTTAsync_create()."]
    #[doc = " @param context A pointer to any application-specific context. The"]
    #[doc = " the <i>context</i> pointer is passed to each of the callback functions to"]
    #[doc = " provide access to the context information in the callback."]
    #[doc = " @param co A pointer to an MQTTAsync_updateConnectOptions() callback"]
    #[doc = " function.  NULL removes the callback setting."]
    pub fn MQTTAsync_setUpdateConnectOptions(
        handle: MQTTAsync,
        context: *mut ::std::os::raw::c_void,
        co: MQTTAsync_updateConnectOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the MQTTPersistence_beforeWrite() callback function for a client."]
    #[doc = " @param handle A valid client handle from a successful call to MQTTAsync_create()."]
    #[doc = " @param context A pointer to any application-specific context. The"]
    #[doc = " the <i>context</i> pointer is passed to the callback function to"]
    #[doc = " provide access to the context information in the callback."]
    #[doc = " @param co A pointer to an MQTTPersistence_beforeWrite() callback"]
    #[doc = " function.  NULL removes the callback setting."]
    pub fn MQTTAsync_setBeforePersistenceWrite(
        handle: MQTTAsync,
        context: *mut ::std::os::raw::c_void,
        co: MQTTPersistence_beforeWrite,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the MQTTPersistence_afterRead() callback function for a client."]
    #[doc = " @param handle A valid client handle from a successful call to MQTTAsync_create()."]
    #[doc = " @param context A pointer to any application-specific context. The"]
    #[doc = " the <i>context</i> pointer is passed to the callback function to"]
    #[doc = " provide access to the context information in the callback."]
    #[doc = " @param co A pointer to an MQTTPersistence_beforeWrite() callback"]
    #[doc = " function.  NULL removes the callback setting."]
    pub fn MQTTAsync_setAfterPersistenceRead(
        handle: MQTTAsync,
        context: *mut ::std::os::raw::c_void,
        co: MQTTPersistence_afterRead,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The data returned on completion of an unsuccessful API call in the response callback onFailure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_failureData {
    #[doc = " A token identifying the failed request."]
    pub token: MQTTAsync_token,
    #[doc = " A numeric code identifying the error."]
    pub code: ::std::os::raw::c_int,
    #[doc = " Optional text explaining the error. Can be NULL."]
    pub message: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_MQTTAsync_failureData() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_failureData>(),
        16usize,
        concat!("Size of: ", stringify!(MQTTAsync_failureData))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_failureData>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_failureData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_failureData>())).token as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_failureData),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_failureData>())).code as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_failureData),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_failureData>())).message as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_failureData),
            "::",
            stringify!(message)
        )
    );
}
#[doc = " The data returned on completion of an unsuccessful API call in the response callback onFailure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_failureData5 {
    #[doc = " The eyecatcher for this structure.  Will be MQFD."]
    pub struct_id: [::std::os::raw::c_char; 4usize],
    #[doc = " The version number of this structure.  Will be 0"]
    pub struct_version: ::std::os::raw::c_int,
    #[doc = " A token identifying the failed request."]
    pub token: MQTTAsync_token,
    #[doc = " The MQTT reason code returned."]
    pub reasonCode: MQTTReasonCodes,
    #[doc = " The MQTT properties on the ack, if any."]
    pub properties: MQTTProperties,
    #[doc = " A numeric code identifying the MQTT client library error."]
    pub code: ::std::os::raw::c_int,
    #[doc = " Optional further text explaining the error. Can be NULL."]
    pub message: *const ::std::os::raw::c_char,
    #[doc = " Packet type on which the failure occurred - used for publish QoS 1/2 exchanges"]
    pub packet_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MQTTAsync_failureData5() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_failureData5>(),
        64usize,
        concat!("Size of: ", stringify!(MQTTAsync_failureData5))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_failureData5>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_failureData5))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_failureData5>())).struct_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_failureData5),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_failureData5>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_failureData5),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_failureData5>())).token as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_failureData5),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_failureData5>())).reasonCode as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_failureData5),
            "::",
            stringify!(reasonCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_failureData5>())).properties as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_failureData5),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_failureData5>())).code as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_failureData5),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_failureData5>())).message as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_failureData5),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_failureData5>())).packet_type as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_failureData5),
            "::",
            stringify!(packet_type)
        )
    );
}
#[doc = " The data returned on completion of a successful API call in the response callback onSuccess."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MQTTAsync_successData {
    #[doc = " A token identifying the successful request. Can be used to refer to the request later."]
    pub token: MQTTAsync_token,
    pub alt: MQTTAsync_successData__bindgen_ty_1,
}
#[doc = " A union of the different values that can be returned for subscribe, unsubscribe and publish."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union MQTTAsync_successData__bindgen_ty_1 {
    #[doc = " For subscribe, the granted QoS of the subscription returned by the server."]
    #[doc = " Also for subscribeMany, if only 1 subscription was requested."]
    pub qos: ::std::os::raw::c_int,
    #[doc = " For subscribeMany, if more than one subscription was requested,"]
    #[doc = " the list of granted QoSs of the subscriptions returned by the server."]
    pub qosList: *mut ::std::os::raw::c_int,
    pub pub_: MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1,
    pub connect: MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2,
}
#[doc = " For publish, the message being sent to the server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< the message being sent to the server"]
    pub message: MQTTAsync_message,
    #[doc = "< the topic destination for the message"]
    pub destinationName: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1>())).message
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1>()))
                .destinationName as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(destinationName)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< the connection string of the server"]
    pub serverURI: *mut ::std::os::raw::c_char,
    #[doc = "< the version of MQTT being used"]
    pub MQTTVersion: ::std::os::raw::c_int,
    #[doc = "< the session present flag returned from the server"]
    pub sessionPresent: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2>())).serverURI
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(serverURI)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2>()))
                .MQTTVersion as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(MQTTVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2>()))
                .sessionPresent as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(sessionPresent)
        )
    );
}
#[test]
fn bindgen_test_layout_MQTTAsync_successData__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_successData__bindgen_ty_1>(),
        72usize,
        concat!("Size of: ", stringify!(MQTTAsync_successData__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_successData__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_successData__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1>())).qos as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1),
            "::",
            stringify!(qos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1>())).qosList as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1),
            "::",
            stringify!(qosList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1>())).pub_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1),
            "::",
            stringify!(pub_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData__bindgen_ty_1>())).connect as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData__bindgen_ty_1),
            "::",
            stringify!(connect)
        )
    );
}
#[test]
fn bindgen_test_layout_MQTTAsync_successData() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_successData>(),
        80usize,
        concat!("Size of: ", stringify!(MQTTAsync_successData))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_successData>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_successData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_successData>())).token as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_successData>())).alt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData),
            "::",
            stringify!(alt)
        )
    );
}
#[doc = " The data returned on completion of a successful API call in the response callback onSuccess."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MQTTAsync_successData5 {
    #[doc = "< The eyecatcher for this structure.  Will be MQSD."]
    pub struct_id: [::std::os::raw::c_char; 4usize],
    #[doc = "< The version number of this structure.  Will be 0"]
    pub struct_version: ::std::os::raw::c_int,
    #[doc = " A token identifying the successful request. Can be used to refer to the request later."]
    pub token: MQTTAsync_token,
    #[doc = "< MQTT V5 reason code returned"]
    pub reasonCode: MQTTReasonCodes,
    #[doc = "< MQTT V5 properties returned, if any"]
    pub properties: MQTTProperties,
    pub alt: MQTTAsync_successData5__bindgen_ty_1,
}
#[doc = " A union of the different values that can be returned for subscribe, unsubscribe and publish."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union MQTTAsync_successData5__bindgen_ty_1 {
    pub sub: MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_1,
    pub pub_: MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_2,
    pub connect: MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_3,
    pub unsub: MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_4,
}
#[doc = " For subscribeMany, the list of reasonCodes returned by the server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< the number of reason codes in the reasonCodes array"]
    pub reasonCodeCount: ::std::os::raw::c_int,
    #[doc = "< an array of reasonCodes"]
    pub reasonCodes: *mut MQTTReasonCodes,
}
#[test]
fn bindgen_test_layout_MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_1>()))
                .reasonCodeCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(reasonCodeCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_1>()))
                .reasonCodes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(reasonCodes)
        )
    );
}
#[doc = " For publish, the message being sent to the server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< the message being sent to the server"]
    pub message: MQTTAsync_message,
    #[doc = "< the topic destination for the message"]
    pub destinationName: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_2>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_2>())).message
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_2>()))
                .destinationName as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(destinationName)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< the connection string of the server"]
    pub serverURI: *mut ::std::os::raw::c_char,
    #[doc = "< the version of MQTT being used"]
    pub MQTTVersion: ::std::os::raw::c_int,
    #[doc = "< the session present flag returned from the server"]
    pub sessionPresent: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_3>())).serverURI
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(serverURI)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_3>()))
                .MQTTVersion as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(MQTTVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_3>()))
                .sessionPresent as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sessionPresent)
        )
    );
}
#[doc = " For unsubscribeMany, the list of reasonCodes returned by the server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< the number of reason codes in the reasonCodes array"]
    pub reasonCodeCount: ::std::os::raw::c_int,
    #[doc = "< an array of reasonCodes"]
    pub reasonCodes: *mut MQTTReasonCodes,
}
#[test]
fn bindgen_test_layout_MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_4>()))
                .reasonCodeCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(reasonCodeCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_4>()))
                .reasonCodes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(reasonCodes)
        )
    );
}
#[test]
fn bindgen_test_layout_MQTTAsync_successData5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_successData5__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_successData5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5__bindgen_ty_1>())).sub as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1),
            "::",
            stringify!(sub)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5__bindgen_ty_1>())).pub_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1),
            "::",
            stringify!(pub_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5__bindgen_ty_1>())).connect as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5__bindgen_ty_1>())).unsub as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5__bindgen_ty_1),
            "::",
            stringify!(unsub)
        )
    );
}
#[test]
fn bindgen_test_layout_MQTTAsync_successData5() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_successData5>(),
        112usize,
        concat!("Size of: ", stringify!(MQTTAsync_successData5))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_successData5>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_successData5))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5>())).struct_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_successData5>())).token as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5>())).reasonCode as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5),
            "::",
            stringify!(reasonCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_successData5>())).properties as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_successData5>())).alt as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_successData5),
            "::",
            stringify!(alt)
        )
    );
}
#[doc = " This is a callback function. The client application"]
#[doc = " must provide an implementation of this function to enable asynchronous"]
#[doc = " notification of the successful completion of an API call. The function is"]
#[doc = " registered with the client library by passing it as an argument in"]
#[doc = " ::MQTTAsync_responseOptions."]
#[doc = ""]
#[doc = " <b>Note:</b> Neither MQTTAsync_create() nor MQTTAsync_destroy() should be"]
#[doc = " called within this callback."]
#[doc = " @param context A pointer to the <i>context</i> value originally passed to"]
#[doc = " ::MQTTAsync_responseOptions, which contains any application-specific context."]
#[doc = " @param response Any success data associated with the API completion."]
pub type MQTTAsync_onSuccess = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        response: *mut MQTTAsync_successData,
    ),
>;
#[doc = " This is a callback function, the MQTT V5 version of ::MQTTAsync_onSuccess."]
#[doc = " The client application"]
#[doc = " must provide an implementation of this function to enable asynchronous"]
#[doc = " notification of the successful completion of an API call. The function is"]
#[doc = " registered with the client library by passing it as an argument in"]
#[doc = " ::MQTTAsync_responseOptions."]
#[doc = ""]
#[doc = " <b>Note:</b> Neither MQTTAsync_create() nor MQTTAsync_destroy() should be"]
#[doc = " called within this callback."]
#[doc = " @param context A pointer to the <i>context</i> value originally passed to"]
#[doc = " ::MQTTAsync_responseOptions, which contains any application-specific context."]
#[doc = " @param response Any success data associated with the API completion."]
pub type MQTTAsync_onSuccess5 = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        response: *mut MQTTAsync_successData5,
    ),
>;
#[doc = " This is a callback function. The client application"]
#[doc = " must provide an implementation of this function to enable asynchronous"]
#[doc = " notification of the unsuccessful completion of an API call. The function is"]
#[doc = " registered with the client library by passing it as an argument in"]
#[doc = " ::MQTTAsync_responseOptions."]
#[doc = ""]
#[doc = " <b>Note:</b> Neither MQTTAsync_create() nor MQTTAsync_destroy() should be"]
#[doc = " called within this callback."]
#[doc = " @param context A pointer to the <i>context</i> value originally passed to"]
#[doc = " ::MQTTAsync_responseOptions, which contains any application-specific context."]
#[doc = " @param response Failure data associated with the API completion."]
pub type MQTTAsync_onFailure = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        response: *mut MQTTAsync_failureData,
    ),
>;
#[doc = " This is a callback function, the MQTT V5 version of ::MQTTAsync_onFailure."]
#[doc = " The application must provide an implementation of this function to enable asynchronous"]
#[doc = " notification of the unsuccessful completion of an API call. The function is"]
#[doc = " registered with the client library by passing it as an argument in"]
#[doc = " ::MQTTAsync_responseOptions."]
#[doc = ""]
#[doc = " <b>Note:</b> Neither MQTTAsync_create() nor MQTTAsync_destroy() should be"]
#[doc = " called within this callback."]
#[doc = " @param context A pointer to the <i>context</i> value originally passed to"]
#[doc = " ::MQTTAsync_responseOptions, which contains any application-specific context."]
#[doc = " @param response Failure data associated with the API completion."]
pub type MQTTAsync_onFailure5 = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        response: *mut MQTTAsync_failureData5,
    ),
>;
#[doc = " Structure to define call options.  For MQTT 5.0 there is input data as well as that"]
#[doc = " describing the response method.  So there is now also a synonym ::MQTTAsync_callOptions"]
#[doc = " to better reflect the use.  This responseOptions name is kept for backward"]
#[doc = " compatibility."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_responseOptions {
    #[doc = " The eyecatcher for this structure.  Must be MQTR"]
    pub struct_id: [::std::os::raw::c_char; 4usize],
    #[doc = " The version number of this structure.  Must be 0 or 1"]
    #[doc = "   if 0, no MQTTV5 options"]
    pub struct_version: ::std::os::raw::c_int,
    #[doc = " A pointer to a callback function to be called if the API call successfully"]
    #[doc = " completes.  Can be set to NULL, in which case no indication of successful"]
    #[doc = " completion will be received."]
    pub onSuccess: MQTTAsync_onSuccess,
    #[doc = " A pointer to a callback function to be called if the API call fails."]
    #[doc = " Can be set to NULL, in which case no indication of unsuccessful"]
    #[doc = " completion will be received."]
    pub onFailure: MQTTAsync_onFailure,
    #[doc = " A pointer to any application-specific context. The"]
    #[doc = " the <i>context</i> pointer is passed to success or failure callback functions to"]
    #[doc = " provide access to the context information in the callback."]
    pub context: *mut ::std::os::raw::c_void,
    #[doc = " A token is returned from the call.  It can be used to track"]
    #[doc = " the state of this request, both in the callbacks and in future calls"]
    #[doc = " such as ::MQTTAsync_waitForCompletion."]
    pub token: MQTTAsync_token,
    #[doc = " A pointer to a callback function to be called if the API call successfully"]
    #[doc = " completes.  Can be set to NULL, in which case no indication of successful"]
    #[doc = " completion will be received."]
    pub onSuccess5: MQTTAsync_onSuccess5,
    #[doc = " A pointer to a callback function to be called if the API call successfully"]
    #[doc = " completes.  Can be set to NULL, in which case no indication of successful"]
    #[doc = " completion will be received."]
    pub onFailure5: MQTTAsync_onFailure5,
    #[doc = " MQTT V5 input properties"]
    pub properties: MQTTProperties,
    pub subscribeOptions: MQTTSubscribe_options,
    pub subscribeOptionsCount: ::std::os::raw::c_int,
    pub subscribeOptionsList: *mut MQTTSubscribe_options,
}
#[test]
fn bindgen_test_layout_MQTTAsync_responseOptions() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_responseOptions>(),
        104usize,
        concat!("Size of: ", stringify!(MQTTAsync_responseOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_responseOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_responseOptions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).struct_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).struct_version as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).onSuccess as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(onSuccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).onFailure as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(onFailure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).context as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).token as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).onSuccess5 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(onSuccess5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).onFailure5 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(onFailure5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).properties as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).subscribeOptions as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(subscribeOptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).subscribeOptionsCount as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(subscribeOptionsCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_responseOptions>())).subscribeOptionsList as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_responseOptions),
            "::",
            stringify!(subscribeOptionsList)
        )
    );
}
#[doc = " A synonym for responseOptions to better reflect its usage since MQTT 5.0"]
pub type MQTTAsync_callOptions = MQTTAsync_responseOptions;
extern "C" {
    #[doc = " This function sets the global callback functions for a specific client."]
    #[doc = " If your client application doesn't use a particular callback, set the"]
    #[doc = " relevant parameter to NULL. Any necessary message acknowledgements and"]
    #[doc = " status communications are handled in the background without any intervention"]
    #[doc = " from the client application.  If you do not set a messageArrived callback"]
    #[doc = " function, you will not be notified of the receipt of any messages as a"]
    #[doc = " result of a subscription."]
    #[doc = ""]
    #[doc = " <b>Note:</b> The MQTT client must be disconnected when this function is"]
    #[doc = " called."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @param context A pointer to any application-specific context. The"]
    #[doc = " the <i>context</i> pointer is passed to each of the callback functions to"]
    #[doc = " provide access to the context information in the callback."]
    #[doc = " @param cl A pointer to an MQTTAsync_connectionLost() callback"]
    #[doc = " function. You can set this to NULL if your application doesn't handle"]
    #[doc = " disconnections."]
    #[doc = " @param ma A pointer to an MQTTAsync_messageArrived() callback"]
    #[doc = " function.  If this callback is not set, an error will be returned."]
    #[doc = " You must set this callback because otherwise there would be"]
    #[doc = " no way to deliver any incoming messages."]
    #[doc = " @param dc A pointer to an MQTTAsync_deliveryComplete() callback"]
    #[doc = " function. You can set this to NULL if you do not want to check"]
    #[doc = " for successful delivery."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the callbacks were correctly set,"]
    #[doc = " ::MQTTASYNC_FAILURE if an error occurred."]
    pub fn MQTTAsync_setCallbacks(
        handle: MQTTAsync,
        context: *mut ::std::os::raw::c_void,
        cl: MQTTAsync_connectionLost,
        ma: MQTTAsync_messageArrived,
        dc: MQTTAsync_deliveryComplete,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function sets the callback function for a connection lost event for"]
    #[doc = " a specific client. Any necessary message acknowledgements and status"]
    #[doc = " communications are handled in the background without any intervention"]
    #[doc = " from the client application."]
    #[doc = ""]
    #[doc = " <b>Note:</b> The MQTT client must be disconnected when this function is"]
    #[doc = " called."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @param context A pointer to any application-specific context. The"]
    #[doc = " the <i>context</i> pointer is passed the callback functions to provide"]
    #[doc = " access to the context information in the callback."]
    #[doc = " @param cl A pointer to an MQTTAsync_connectionLost() callback"]
    #[doc = " function. You can set this to NULL if your application doesn't handle"]
    #[doc = " disconnections."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the callbacks were correctly set,"]
    #[doc = " ::MQTTASYNC_FAILURE if an error occurred."]
    pub fn MQTTAsync_setConnectionLostCallback(
        handle: MQTTAsync,
        context: *mut ::std::os::raw::c_void,
        cl: MQTTAsync_connectionLost,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function sets the callback function for a message arrived event for"]
    #[doc = " a specific client. Any necessary message acknowledgements and status"]
    #[doc = " communications are handled in the background without any intervention"]
    #[doc = " from the client application.  If you do not set a messageArrived callback"]
    #[doc = " function, you will not be notified of the receipt of any messages as a"]
    #[doc = " result of a subscription."]
    #[doc = ""]
    #[doc = " <b>Note:</b> The MQTT client must be disconnected when this function is"]
    #[doc = " called."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @param context A pointer to any application-specific context. The"]
    #[doc = " the <i>context</i> pointer is passed to the callback functions to provide"]
    #[doc = " access to the context information in the callback."]
    #[doc = " @param ma A pointer to an MQTTAsync_messageArrived() callback"]
    #[doc = " function.  You can set this to NULL if your application doesn't handle"]
    #[doc = " receipt of messages."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the callbacks were correctly set,"]
    #[doc = " ::MQTTASYNC_FAILURE if an error occurred."]
    pub fn MQTTAsync_setMessageArrivedCallback(
        handle: MQTTAsync,
        context: *mut ::std::os::raw::c_void,
        ma: MQTTAsync_messageArrived,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function sets the callback function for a delivery complete event"]
    #[doc = " for a specific client. Any necessary message acknowledgements and status"]
    #[doc = " communications are handled in the background without any intervention"]
    #[doc = " from the client application."]
    #[doc = ""]
    #[doc = " <b>Note:</b> The MQTT client must be disconnected when this function is"]
    #[doc = " called."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @param context A pointer to any application-specific context. The"]
    #[doc = " the <i>context</i> pointer is passed to the callback functions to provide"]
    #[doc = " access to the context information in the callback."]
    #[doc = " @param dc A pointer to an MQTTAsync_deliveryComplete() callback"]
    #[doc = " function. You can set this to NULL if you do not want to check"]
    #[doc = " for successful delivery."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the callbacks were correctly set,"]
    #[doc = " ::MQTTASYNC_FAILURE if an error occurred."]
    pub fn MQTTAsync_setDeliveryCompleteCallback(
        handle: MQTTAsync,
        context: *mut ::std::os::raw::c_void,
        dc: MQTTAsync_deliveryComplete,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the MQTTAsync_connected() callback function for a client."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @param context A pointer to any application-specific context. The"]
    #[doc = " the <i>context</i> pointer is passed to each of the callback functions to"]
    #[doc = " provide access to the context information in the callback."]
    #[doc = " @param co A pointer to an MQTTAsync_connected() callback"]
    #[doc = " function.  NULL removes the callback setting."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the callbacks were correctly set,"]
    #[doc = " ::MQTTASYNC_FAILURE if an error occurred."]
    pub fn MQTTAsync_setConnected(
        handle: MQTTAsync,
        context: *mut ::std::os::raw::c_void,
        co: MQTTAsync_connected,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reconnects a client with the previously used connect options.  Connect"]
    #[doc = " must have previously been called for this to work."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the callbacks were correctly set,"]
    #[doc = " ::MQTTASYNC_FAILURE if an error occurred."]
    pub fn MQTTAsync_reconnect(handle: MQTTAsync) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function creates an MQTT client ready for connection to the"]
    #[doc = " specified server and using the specified persistent storage (see"]
    #[doc = " MQTTAsync_persistence). See also MQTTAsync_destroy()."]
    #[doc = " @param handle A pointer to an ::MQTTAsync handle. The handle is"]
    #[doc = " populated with a valid client reference following a successful return from"]
    #[doc = " this function."]
    #[doc = " @param serverURI A null-terminated string specifying the server to"]
    #[doc = " which the client will connect. It takes the form <i>protocol://host:port</i>."]
    #[doc = " <i>protocol</i> must be <i>tcp</i>, <i>ssl</i>, <i>ws</i> or <i>wss</i>."]
    #[doc = " The TLS enabled prefixes (ssl, wss) are only valid if a TLS version of"]
    #[doc = " the library is linked with."]
    #[doc = " For <i>host</i>, you can"]
    #[doc = " specify either an IP address or a host name. For instance, to connect to"]
    #[doc = " a server running on the local machines with the default MQTT port, specify"]
    #[doc = " <i>tcp://localhost:1883</i>."]
    #[doc = " @param clientId The client identifier passed to the server when the"]
    #[doc = " client connects to it. It is a null-terminated UTF-8 encoded string."]
    #[doc = " @param persistence_type The type of persistence to be used by the client:"]
    #[doc = " <br>"]
    #[doc = " ::MQTTCLIENT_PERSISTENCE_NONE: Use in-memory persistence. If the device or"]
    #[doc = " system on which the client is running fails or is switched off, the current"]
    #[doc = " state of any in-flight messages is lost and some messages may not be"]
    #[doc = " delivered even at QoS1 and QoS2."]
    #[doc = " <br>"]
    #[doc = " ::MQTTCLIENT_PERSISTENCE_DEFAULT: Use the default (file system-based)"]
    #[doc = " persistence mechanism. Status about in-flight messages is held in persistent"]
    #[doc = " storage and provides some protection against message loss in the case of"]
    #[doc = " unexpected failure."]
    #[doc = " <br>"]
    #[doc = " ::MQTTCLIENT_PERSISTENCE_USER: Use an application-specific persistence"]
    #[doc = " implementation. Using this type of persistence gives control of the"]
    #[doc = " persistence mechanism to the application. The application has to implement"]
    #[doc = " the MQTTClient_persistence interface."]
    #[doc = " @param persistence_context If the application uses"]
    #[doc = " ::MQTTCLIENT_PERSISTENCE_NONE persistence, this argument is unused and should"]
    #[doc = " be set to NULL. For ::MQTTCLIENT_PERSISTENCE_DEFAULT persistence, it"]
    #[doc = " should be set to the location of the persistence directory (if set"]
    #[doc = " to NULL, the persistence directory used is the working directory)."]
    #[doc = " Applications that use ::MQTTCLIENT_PERSISTENCE_USER persistence set this"]
    #[doc = " argument to point to a valid MQTTClient_persistence structure."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the client is successfully created, otherwise"]
    #[doc = " an error code is returned."]
    pub fn MQTTAsync_create(
        handle: *mut MQTTAsync,
        serverURI: *const ::std::os::raw::c_char,
        clientId: *const ::std::os::raw::c_char,
        persistence_type: ::std::os::raw::c_int,
        persistence_context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Options for the ::MQTTAsync_createWithOptions call"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_createOptions {
    #[doc = " The eyecatcher for this structure.  must be MQCO."]
    pub struct_id: [::std::os::raw::c_char; 4usize],
    #[doc = " The version number of this structure.  Must be 0, 1, 2 or 3"]
    #[doc = " 0 means no MQTTVersion"]
    #[doc = " 1 means no allowDisconnectedSendAtAnyTime, deleteOldestMessages, restoreMessages"]
    #[doc = " 2 means no persistQoS0"]
    pub struct_version: ::std::os::raw::c_int,
    #[doc = " Whether to allow messages to be sent when the client library is not connected."]
    pub sendWhileDisconnected: ::std::os::raw::c_int,
    #[doc = " The maximum number of messages allowed to be buffered while not connected."]
    pub maxBufferedMessages: ::std::os::raw::c_int,
    #[doc = " Whether the MQTT version is 3.1, 3.1.1, or 5.  To use V5, this must be set."]
    #[doc = "  MQTT V5 has to be chosen here, because during the create call the message persistence"]
    #[doc = "  is initialized, and we want to know whether the format of any persisted messages"]
    #[doc = "  is appropriate for the MQTT version we are going to connect with.  Selecting 3.1 or"]
    #[doc = "  3.1.1 and attempting to read 5.0 persisted messages will result in an error on create."]
    pub MQTTVersion: ::std::os::raw::c_int,
    #[doc = " Allow sending of messages while disconnected before a first successful connect."]
    pub allowDisconnectedSendAtAnyTime: ::std::os::raw::c_int,
    pub deleteOldestMessages: ::std::os::raw::c_int,
    pub restoreMessages: ::std::os::raw::c_int,
    pub persistQoS0: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MQTTAsync_createOptions() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_createOptions>(),
        36usize,
        concat!("Size of: ", stringify!(MQTTAsync_createOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_createOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(MQTTAsync_createOptions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_createOptions>())).struct_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_createOptions),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_createOptions>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_createOptions),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_createOptions>())).sendWhileDisconnected as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_createOptions),
            "::",
            stringify!(sendWhileDisconnected)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_createOptions>())).maxBufferedMessages as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_createOptions),
            "::",
            stringify!(maxBufferedMessages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_createOptions>())).MQTTVersion as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_createOptions),
            "::",
            stringify!(MQTTVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_createOptions>())).allowDisconnectedSendAtAnyTime
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_createOptions),
            "::",
            stringify!(allowDisconnectedSendAtAnyTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_createOptions>())).deleteOldestMessages as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_createOptions),
            "::",
            stringify!(deleteOldestMessages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_createOptions>())).restoreMessages as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_createOptions),
            "::",
            stringify!(restoreMessages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_createOptions>())).persistQoS0 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_createOptions),
            "::",
            stringify!(persistQoS0)
        )
    );
}
extern "C" {
    pub fn MQTTAsync_createWithOptions(
        handle: *mut MQTTAsync,
        serverURI: *const ::std::os::raw::c_char,
        clientId: *const ::std::os::raw::c_char,
        persistence_type: ::std::os::raw::c_int,
        persistence_context: *mut ::std::os::raw::c_void,
        options: *mut MQTTAsync_createOptions,
    ) -> ::std::os::raw::c_int;
}
#[doc = " MQTTAsync_willOptions defines the MQTT \"Last Will and Testament\" (LWT) settings for"]
#[doc = " the client. In the event that a client unexpectedly loses its connection to"]
#[doc = " the server, the server publishes the LWT message to the LWT topic on"]
#[doc = " behalf of the client. This allows other clients (subscribed to the LWT topic)"]
#[doc = " to be made aware that the client has disconnected. To enable the LWT"]
#[doc = " function for a specific client, a valid pointer to an MQTTAsync_willOptions"]
#[doc = " structure is passed in the MQTTAsync_connectOptions structure used in the"]
#[doc = " MQTTAsync_connect() call that connects the client to the server. The pointer"]
#[doc = " to MQTTAsync_willOptions can be set to NULL if the LWT function is not"]
#[doc = " required."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_willOptions {
    #[doc = " The eyecatcher for this structure.  must be MQTW."]
    pub struct_id: [::std::os::raw::c_char; 4usize],
    #[doc = " The version number of this structure.  Must be 0 or 1"]
    #[doc = "0 indicates no binary will message support"]
    pub struct_version: ::std::os::raw::c_int,
    #[doc = " The LWT topic to which the LWT message will be published."]
    pub topicName: *const ::std::os::raw::c_char,
    #[doc = " The LWT payload."]
    pub message: *const ::std::os::raw::c_char,
    #[doc = " The retained flag for the LWT message (see MQTTAsync_message.retained)."]
    pub retained: ::std::os::raw::c_int,
    #[doc = " The quality of service setting for the LWT message (see"]
    #[doc = " MQTTAsync_message.qos and @ref qos)."]
    pub qos: ::std::os::raw::c_int,
    pub payload: MQTTAsync_willOptions__bindgen_ty_1,
}
#[doc = " The LWT payload in binary form. This is only checked and used if the message option is NULL"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_willOptions__bindgen_ty_1 {
    #[doc = "< binary payload length"]
    pub len: ::std::os::raw::c_int,
    #[doc = "< binary payload data"]
    pub data: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MQTTAsync_willOptions__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_willOptions__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(MQTTAsync_willOptions__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_willOptions__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_willOptions__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_willOptions__bindgen_ty_1>())).len as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_willOptions__bindgen_ty_1>())).data as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_MQTTAsync_willOptions() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_willOptions>(),
        48usize,
        concat!("Size of: ", stringify!(MQTTAsync_willOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_willOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_willOptions))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_willOptions>())).struct_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_willOptions>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_willOptions>())).topicName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions),
            "::",
            stringify!(topicName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_willOptions>())).message as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_willOptions>())).retained as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions),
            "::",
            stringify!(retained)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_willOptions>())).qos as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions),
            "::",
            stringify!(qos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_willOptions>())).payload as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_willOptions),
            "::",
            stringify!(payload)
        )
    );
}
#[doc = " MQTTAsync_sslProperties defines the settings to establish an SSL/TLS connection using the"]
#[doc = " OpenSSL library. It covers the following scenarios:"]
#[doc = " - Server authentication: The client needs the digital certificate of the server. It is included"]
#[doc = "   in a store containting trusted material (also known as \"trust store\")."]
#[doc = " - Mutual authentication: Both client and server are authenticated during the SSL handshake. In"]
#[doc = "   addition to the digital certificate of the server in a trust store, the client will need its own"]
#[doc = "   digital certificate and the private key used to sign its digital certificate stored in a \"key store\"."]
#[doc = " - Anonymous connection: Both client and server do not get authenticated and no credentials are needed"]
#[doc = "   to establish an SSL connection. Note that this scenario is not fully secure since it is subject to"]
#[doc = "   man-in-the-middle attacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_SSLOptions {
    #[doc = " The eyecatcher for this structure.  Must be MQTS"]
    pub struct_id: [::std::os::raw::c_char; 4usize],
    #[doc = " The version number of this structure. Must be 0, 1, 2, 3, 4 or 5."]
    #[doc = " 0 means no sslVersion"]
    #[doc = " 1 means no verify, CApath"]
    #[doc = " 2 means no ssl_error_context, ssl_error_cb"]
    #[doc = " 3 means no ssl_psk_cb, ssl_psk_context, disableDefaultTrustStore"]
    #[doc = " 4 means no protos, protos_len"]
    pub struct_version: ::std::os::raw::c_int,
    #[doc = " The file in PEM format containing the public digital certificates trusted by the client."]
    pub trustStore: *const ::std::os::raw::c_char,
    #[doc = " The file in PEM format containing the public certificate chain of the client. It may also include"]
    #[doc = " the client's private key."]
    pub keyStore: *const ::std::os::raw::c_char,
    #[doc = " If not included in the sslKeyStore, this setting points to the file in PEM format containing"]
    #[doc = " the client's private key."]
    pub privateKey: *const ::std::os::raw::c_char,
    #[doc = " The password to load the client's privateKey if encrypted."]
    pub privateKeyPassword: *const ::std::os::raw::c_char,
    #[doc = " The list of cipher suites that the client will present to the server during the SSL handshake. For a"]
    #[doc = " full explanation of the cipher list format, please see the OpenSSL on-line documentation:"]
    #[doc = " http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT"]
    #[doc = " If this setting is ommitted, its default value will be \"ALL\", that is, all the cipher suites -excluding"]
    #[doc = " those offering no encryption- will be considered."]
    #[doc = " This setting can be used to set an SSL anonymous connection (\"aNULL\" string value, for instance)."]
    pub enabledCipherSuites: *const ::std::os::raw::c_char,
    #[doc = " True/False option to enable verification of the server certificate"]
    pub enableServerCertAuth: ::std::os::raw::c_int,
    #[doc = " The SSL/TLS version to use. Specify one of MQTT_SSL_VERSION_DEFAULT (0),"]
    #[doc = " MQTT_SSL_VERSION_TLS_1_0 (1), MQTT_SSL_VERSION_TLS_1_1 (2) or MQTT_SSL_VERSION_TLS_1_2 (3)."]
    #[doc = " Only used if struct_version is >= 1."]
    pub sslVersion: ::std::os::raw::c_int,
    #[doc = " Whether to carry out post-connect checks, including that a certificate"]
    #[doc = " matches the given host name."]
    #[doc = " Exists only if struct_version >= 2"]
    pub verify: ::std::os::raw::c_int,
    #[doc = " From the OpenSSL documentation:"]
    #[doc = " If CApath is not NULL, it points to a directory containing CA certificates in PEM format."]
    #[doc = " Exists only if struct_version >= 2"]
    pub CApath: *const ::std::os::raw::c_char,
    #[doc = " Callback function for OpenSSL error handler ERR_print_errors_cb"]
    #[doc = " Exists only if struct_version >= 3"]
    pub ssl_error_cb: ::std::option::Option<
        unsafe extern "C" fn(
            str_: *const ::std::os::raw::c_char,
            len: size_t,
            u: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Application-specific contex for OpenSSL error handler ERR_print_errors_cb"]
    #[doc = " Exists only if struct_version >= 3"]
    pub ssl_error_context: *mut ::std::os::raw::c_void,
    #[doc = " Callback function for setting TLS-PSK options. Parameters correspond to that of"]
    #[doc = " SSL_CTX_set_psk_client_callback, except for u which is the pointer ssl_psk_context."]
    #[doc = " Exists only if struct_version >= 4"]
    pub ssl_psk_cb: ::std::option::Option<
        unsafe extern "C" fn(
            hint: *const ::std::os::raw::c_char,
            identity: *mut ::std::os::raw::c_char,
            max_identity_len: ::std::os::raw::c_uint,
            psk: *mut ::std::os::raw::c_uchar,
            max_psk_len: ::std::os::raw::c_uint,
            u: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_uint,
    >,
    #[doc = " Application-specific contex for ssl_psk_cb"]
    #[doc = " Exists only if struct_version >= 4"]
    pub ssl_psk_context: *mut ::std::os::raw::c_void,
    #[doc = " Don't load default SSL CA. Should be used together with PSK to make sure"]
    #[doc = " regular servers with certificate in place is not accepted."]
    #[doc = " Exists only if struct_version >= 4"]
    pub disableDefaultTrustStore: ::std::os::raw::c_int,
    #[doc = " The protocol-lists must be in wire-format, which is defined as a vector of non-empty, 8-bit length-prefixed, byte strings."]
    #[doc = " The length-prefix byte is not included in the length. Each string is limited to 255 bytes. A byte-string length of 0 is invalid."]
    #[doc = " A truncated byte-string is invalid."]
    #[doc = " Check documentation for SSL_CTX_set_alpn_protos"]
    #[doc = " Exists only if struct_version >= 5"]
    pub protos: *const ::std::os::raw::c_uchar,
    #[doc = " The length of the vector protos vector"]
    #[doc = " Exists only if struct_version >= 5"]
    pub protos_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_MQTTAsync_SSLOptions() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_SSLOptions>(),
        128usize,
        concat!("Size of: ", stringify!(MQTTAsync_SSLOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_SSLOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_SSLOptions))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).struct_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).trustStore as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(trustStore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).keyStore as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(keyStore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).privateKey as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(privateKey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).privateKeyPassword as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(privateKeyPassword)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).enabledCipherSuites as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(enabledCipherSuites)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).enableServerCertAuth as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(enableServerCertAuth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).sslVersion as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(sslVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).verify as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(verify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).CApath as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(CApath)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).ssl_error_cb as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(ssl_error_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).ssl_error_context as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(ssl_error_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).ssl_psk_cb as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(ssl_psk_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).ssl_psk_context as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(ssl_psk_context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).disableDefaultTrustStore as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(disableDefaultTrustStore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).protos as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(protos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_SSLOptions>())).protos_len as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_SSLOptions),
            "::",
            stringify!(protos_len)
        )
    );
}
#[doc = " Utility structure where name/value pairs are needed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_nameValue {
    #[doc = "< name string"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< value string"]
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_MQTTAsync_nameValue() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_nameValue>(),
        16usize,
        concat!("Size of: ", stringify!(MQTTAsync_nameValue))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_nameValue>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_nameValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_nameValue>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_nameValue),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_nameValue>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_nameValue),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " MQTTAsync_connectOptions defines several settings that control the way the"]
#[doc = " client connects to an MQTT server.  Default values are set in"]
#[doc = " MQTTAsync_connectOptions_initializer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_connectOptions {
    #[doc = " The eyecatcher for this structure.  must be MQTC."]
    pub struct_id: [::std::os::raw::c_char; 4usize],
    #[doc = " The version number of this structure.  Must be 0, 1, 2, 3 4 5 6, 7 or 8."]
    #[doc = " 0 signifies no SSL options and no serverURIs"]
    #[doc = " 1 signifies no serverURIs"]
    #[doc = " 2 signifies no MQTTVersion"]
    #[doc = " 3 signifies no automatic reconnect options"]
    #[doc = " 4 signifies no binary password option (just string)"]
    #[doc = " 5 signifies no MQTTV5 properties"]
    #[doc = " 6 signifies no HTTP headers option"]
    #[doc = " 7 signifies no HTTP proxy and HTTPS proxy options"]
    pub struct_version: ::std::os::raw::c_int,
    #[doc = " The \"keep alive\" interval, measured in seconds, defines the maximum time"]
    #[doc = " that should pass without communication between the client and the server"]
    #[doc = " The client will ensure that at least one message travels across the"]
    #[doc = " network within each keep alive period.  In the absence of a data-related"]
    #[doc = " message during the time period, the client sends a very small MQTT"]
    #[doc = " \"ping\" message, which the server will acknowledge. The keep alive"]
    #[doc = " interval enables the client to detect when the server is no longer"]
    #[doc = " available without having to wait for the long TCP/IP timeout."]
    #[doc = " Set to 0 if you do not want any keep alive processing."]
    pub keepAliveInterval: ::std::os::raw::c_int,
    #[doc = " This is a boolean value. The cleansession setting controls the behaviour"]
    #[doc = " of both the client and the server at connection and disconnection time."]
    #[doc = " The client and server both maintain session state information. This"]
    #[doc = " information is used to ensure \"at least once\" and \"exactly once\""]
    #[doc = " delivery, and \"exactly once\" receipt of messages. Session state also"]
    #[doc = " includes subscriptions created by an MQTT client. You can choose to"]
    #[doc = " maintain or discard state information between sessions."]
    #[doc = ""]
    #[doc = " When cleansession is true, the state information is discarded at"]
    #[doc = " connect and disconnect. Setting cleansession to false keeps the state"]
    #[doc = " information. When you connect an MQTT client application with"]
    #[doc = " MQTTAsync_connect(), the client identifies the connection using the"]
    #[doc = " client identifier and the address of the server. The server checks"]
    #[doc = " whether session information for this client"]
    #[doc = " has been saved from a previous connection to the server. If a previous"]
    #[doc = " session still exists, and cleansession=true, then the previous session"]
    #[doc = " information at the client and server is cleared. If cleansession=false,"]
    #[doc = " the previous session is resumed. If no previous session exists, a new"]
    #[doc = " session is started."]
    pub cleansession: ::std::os::raw::c_int,
    #[doc = " This controls how many messages can be in-flight simultaneously."]
    pub maxInflight: ::std::os::raw::c_int,
    #[doc = " This is a pointer to an MQTTAsync_willOptions structure. If your"]
    #[doc = " application does not make use of the Last Will and Testament feature,"]
    #[doc = " set this pointer to NULL."]
    pub will: *mut MQTTAsync_willOptions,
    #[doc = " MQTT servers that support the MQTT v3.1 protocol provide authentication"]
    #[doc = " and authorisation by user name and password. This is the user name"]
    #[doc = " parameter."]
    pub username: *const ::std::os::raw::c_char,
    #[doc = " MQTT servers that support the MQTT v3.1 protocol provide authentication"]
    #[doc = " and authorisation by user name and password. This is the password"]
    #[doc = " parameter."]
    pub password: *const ::std::os::raw::c_char,
    #[doc = " The time interval in seconds to allow a connect to complete."]
    pub connectTimeout: ::std::os::raw::c_int,
    #[doc = " The time interval in seconds after which unacknowledged publish requests are"]
    #[doc = " retried during a TCP session.  With MQTT 3.1.1 and later, retries are"]
    #[doc = " not required except on reconnect.  0 turns off in-session retries, and is the"]
    #[doc = " recommended setting.  Adding retries to an already overloaded network only"]
    #[doc = " exacerbates the problem."]
    pub retryInterval: ::std::os::raw::c_int,
    #[doc = " This is a pointer to an MQTTAsync_SSLOptions structure. If your"]
    #[doc = " application does not make use of SSL, set this pointer to NULL."]
    pub ssl: *mut MQTTAsync_SSLOptions,
    #[doc = " A pointer to a callback function to be called if the connect successfully"]
    #[doc = " completes.  Can be set to NULL, in which case no indication of successful"]
    #[doc = " completion will be received."]
    pub onSuccess: MQTTAsync_onSuccess,
    #[doc = " A pointer to a callback function to be called if the connect fails."]
    #[doc = " Can be set to NULL, in which case no indication of unsuccessful"]
    #[doc = " completion will be received."]
    pub onFailure: MQTTAsync_onFailure,
    #[doc = " A pointer to any application-specific context. The"]
    #[doc = " the <i>context</i> pointer is passed to success or failure callback functions to"]
    #[doc = " provide access to the context information in the callback."]
    pub context: *mut ::std::os::raw::c_void,
    #[doc = " The number of entries in the serverURIs array."]
    pub serverURIcount: ::std::os::raw::c_int,
    #[doc = " An array of null-terminated strings specifying the servers to"]
    #[doc = " which the client will connect. Each string takes the form <i>protocol://host:port</i>."]
    #[doc = " <i>protocol</i> must be <i>tcp</i>, <i>ssl</i>, <i>ws</i> or <i>wss</i>."]
    #[doc = " The TLS enabled prefixes (ssl, wss) are only valid if a TLS version of the library"]
    #[doc = " is linked with."]
    #[doc = " For <i>host</i>, you can"]
    #[doc = " specify either an IP address or a domain name. For instance, to connect to"]
    #[doc = " a server running on the local machines with the default MQTT port, specify"]
    #[doc = " <i>tcp://localhost:1883</i>."]
    pub serverURIs: *const *mut ::std::os::raw::c_char,
    #[doc = " Sets the version of MQTT to be used on the connect."]
    #[doc = " MQTTVERSION_DEFAULT (0) = default: start with 3.1.1, and if that fails, fall back to 3.1"]
    #[doc = " MQTTVERSION_3_1 (3) = only try version 3.1"]
    #[doc = " MQTTVERSION_3_1_1 (4) = only try version 3.1.1"]
    pub MQTTVersion: ::std::os::raw::c_int,
    #[doc = " Reconnect automatically in the case of a connection being lost?"]
    pub automaticReconnect: ::std::os::raw::c_int,
    #[doc = " Minimum retry interval in seconds.  Doubled on each failed retry."]
    pub minRetryInterval: ::std::os::raw::c_int,
    #[doc = " Maximum retry interval in seconds.  The doubling stops here on failed retries."]
    pub maxRetryInterval: ::std::os::raw::c_int,
    pub binarypwd: MQTTAsync_connectOptions__bindgen_ty_1,
    pub cleanstart: ::std::os::raw::c_int,
    #[doc = " MQTT V5 properties for connect"]
    pub connectProperties: *mut MQTTProperties,
    #[doc = " MQTT V5 properties for the will message in the connect"]
    pub willProperties: *mut MQTTProperties,
    #[doc = " A pointer to a callback function to be called if the connect successfully"]
    #[doc = " completes.  Can be set to NULL, in which case no indication of successful"]
    #[doc = " completion will be received."]
    pub onSuccess5: MQTTAsync_onSuccess5,
    #[doc = " A pointer to a callback function to be called if the connect fails."]
    #[doc = " Can be set to NULL, in which case no indication of unsuccessful"]
    #[doc = " completion will be received."]
    pub onFailure5: MQTTAsync_onFailure5,
    #[doc = " HTTP headers for websockets"]
    pub httpHeaders: *const MQTTAsync_nameValue,
    #[doc = " HTTP proxy for websockets"]
    pub httpProxy: *const ::std::os::raw::c_char,
    #[doc = " HTTPS proxy for websockets"]
    pub httpsProxy: *const ::std::os::raw::c_char,
}
#[doc = " Optional binary password.  Only checked and used if the password option is NULL"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_connectOptions__bindgen_ty_1 {
    #[doc = "< binary password length"]
    pub len: ::std::os::raw::c_int,
    #[doc = "< binary password data"]
    pub data: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MQTTAsync_connectOptions__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_connectOptions__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MQTTAsync_connectOptions__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_connectOptions__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MQTTAsync_connectOptions__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions__bindgen_ty_1>())).len as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions__bindgen_ty_1>())).data as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_MQTTAsync_connectOptions() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_connectOptions>(),
        200usize,
        concat!("Size of: ", stringify!(MQTTAsync_connectOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_connectOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_connectOptions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).struct_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).struct_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).keepAliveInterval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(keepAliveInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).cleansession as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(cleansession)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).maxInflight as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(maxInflight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).will as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(will)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).username as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).password as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).connectTimeout as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(connectTimeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).retryInterval as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(retryInterval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).ssl as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(ssl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).onSuccess as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(onSuccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).onFailure as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(onFailure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).context as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).serverURIcount as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(serverURIcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).serverURIs as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(serverURIs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).MQTTVersion as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(MQTTVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).automaticReconnect as *const _
                as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(automaticReconnect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).minRetryInterval as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(minRetryInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).maxRetryInterval as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(maxRetryInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).binarypwd as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(binarypwd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).cleanstart as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(cleanstart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).connectProperties as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(connectProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).willProperties as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(willProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).onSuccess5 as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(onSuccess5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).onFailure5 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(onFailure5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).httpHeaders as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(httpHeaders)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).httpProxy as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(httpProxy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_connectOptions>())).httpsProxy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_connectOptions),
            "::",
            stringify!(httpsProxy)
        )
    );
}
extern "C" {
    #[doc = " This function attempts to connect a previously-created client (see"]
    #[doc = " MQTTAsync_create()) to an MQTT server using the specified options. If you"]
    #[doc = " want to enable asynchronous message and status notifications, you must call"]
    #[doc = " MQTTAsync_setCallbacks() prior to MQTTAsync_connect()."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @param options A pointer to a valid MQTTAsync_connectOptions"]
    #[doc = " structure."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the client connect request was accepted."]
    #[doc = " If the client was unable to connect to the server, an error code is"]
    #[doc = " returned via the onFailure callback, if set."]
    #[doc = " Error codes greater than 0 are returned by the MQTT protocol:<br><br>"]
    #[doc = " <b>1</b>: Connection refused: Unacceptable protocol version<br>"]
    #[doc = " <b>2</b>: Connection refused: Identifier rejected<br>"]
    #[doc = " <b>3</b>: Connection refused: Server unavailable<br>"]
    #[doc = " <b>4</b>: Connection refused: Bad user name or password<br>"]
    #[doc = " <b>5</b>: Connection refused: Not authorized<br>"]
    #[doc = " <b>6-255</b>: Reserved for future use<br>"]
    pub fn MQTTAsync_connect(
        handle: MQTTAsync,
        options: *const MQTTAsync_connectOptions,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Options for the ::MQTTAsync_disconnect call"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTAsync_disconnectOptions {
    #[doc = " The eyecatcher for this structure. Must be MQTD."]
    pub struct_id: [::std::os::raw::c_char; 4usize],
    #[doc = " The version number of this structure.  Must be 0 or 1.  0 signifies no V5 properties"]
    pub struct_version: ::std::os::raw::c_int,
    #[doc = " The client delays disconnection for up to this time (in"]
    #[doc = " milliseconds) in order to allow in-flight message transfers to complete."]
    pub timeout: ::std::os::raw::c_int,
    #[doc = " A pointer to a callback function to be called if the disconnect successfully"]
    #[doc = " completes.  Can be set to NULL, in which case no indication of successful"]
    #[doc = " completion will be received."]
    pub onSuccess: MQTTAsync_onSuccess,
    #[doc = " A pointer to a callback function to be called if the disconnect fails."]
    #[doc = " Can be set to NULL, in which case no indication of unsuccessful"]
    #[doc = " completion will be received."]
    pub onFailure: MQTTAsync_onFailure,
    #[doc = " A pointer to any application-specific context. The"]
    #[doc = " the <i>context</i> pointer is passed to success or failure callback functions to"]
    #[doc = " provide access to the context information in the callback."]
    pub context: *mut ::std::os::raw::c_void,
    #[doc = " MQTT V5 input properties"]
    pub properties: MQTTProperties,
    #[doc = " Reason code for MQTTV5 disconnect"]
    pub reasonCode: MQTTReasonCodes,
    #[doc = " A pointer to a callback function to be called if the disconnect successfully"]
    #[doc = " completes.  Can be set to NULL, in which case no indication of successful"]
    #[doc = " completion will be received."]
    pub onSuccess5: MQTTAsync_onSuccess5,
    #[doc = " A pointer to a callback function to be called if the disconnect fails."]
    #[doc = " Can be set to NULL, in which case no indication of unsuccessful"]
    #[doc = " completion will be received."]
    pub onFailure5: MQTTAsync_onFailure5,
}
#[test]
fn bindgen_test_layout_MQTTAsync_disconnectOptions() {
    assert_eq!(
        ::std::mem::size_of::<MQTTAsync_disconnectOptions>(),
        88usize,
        concat!("Size of: ", stringify!(MQTTAsync_disconnectOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTAsync_disconnectOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTAsync_disconnectOptions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).struct_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(struct_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).struct_version as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(struct_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).timeout as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).onSuccess as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(onSuccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).onFailure as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(onFailure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).context as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).properties as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).reasonCode as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(reasonCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).onSuccess5 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(onSuccess5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTAsync_disconnectOptions>())).onFailure5 as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTAsync_disconnectOptions),
            "::",
            stringify!(onFailure5)
        )
    );
}
extern "C" {
    #[doc = " This function attempts to disconnect the client from the MQTT"]
    #[doc = " server. In order to allow the client time to complete handling of messages"]
    #[doc = " that are in-flight when this function is called, a timeout period is"]
    #[doc = " specified. When the timeout period has expired, the client disconnects even"]
    #[doc = " if there are still outstanding message acknowledgements."]
    #[doc = " The next time the client connects to the same server, any QoS 1 or 2"]
    #[doc = " messages which have not completed will be retried depending on the"]
    #[doc = " cleansession settings for both the previous and the new connection (see"]
    #[doc = " MQTTAsync_connectOptions.cleansession and MQTTAsync_connect())."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @param options The client delays disconnection for up to this time (in"]
    #[doc = " milliseconds) in order to allow in-flight message transfers to complete."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the client successfully disconnects from"]
    #[doc = " the server. An error code is returned if the client was unable to disconnect"]
    #[doc = " from the server"]
    pub fn MQTTAsync_disconnect(
        handle: MQTTAsync,
        options: *const MQTTAsync_disconnectOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function allows the client application to test whether or not a"]
    #[doc = " client is currently connected to the MQTT server."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @return Boolean true if the client is connected, otherwise false."]
    pub fn MQTTAsync_isConnected(handle: MQTTAsync) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function attempts to subscribe a client to a single topic, which may"]
    #[doc = " contain wildcards (see @ref wildcard). This call also specifies the"]
    #[doc = " @ref qos requested for the subscription"]
    #[doc = " (see also MQTTAsync_subscribeMany())."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @param topic The subscription topic, which may include wildcards."]
    #[doc = " @param qos The requested quality of service for the subscription."]
    #[doc = " @param response A pointer to a response options structure. Used to set callback functions."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the subscription request is successful."]
    #[doc = " An error code is returned if there was a problem registering the"]
    #[doc = " subscription."]
    pub fn MQTTAsync_subscribe(
        handle: MQTTAsync,
        topic: *const ::std::os::raw::c_char,
        qos: ::std::os::raw::c_int,
        response: *mut MQTTAsync_responseOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function attempts to subscribe a client to a list of topics, which may"]
    #[doc = " contain wildcards (see @ref wildcard). This call also specifies the"]
    #[doc = " @ref qos requested for each topic (see also MQTTAsync_subscribe())."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @param count The number of topics for which the client is requesting"]
    #[doc = " subscriptions."]
    #[doc = " @param topic An array (of length <i>count</i>) of pointers to"]
    #[doc = " topics, each of which may include wildcards."]
    #[doc = " @param qos An array (of length <i>count</i>) of @ref qos"]
    #[doc = " values. qos[n] is the requested QoS for topic[n]."]
    #[doc = " @param response A pointer to a response options structure. Used to set callback functions."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the subscription request is successful."]
    #[doc = " An error code is returned if there was a problem registering the"]
    #[doc = " subscriptions."]
    pub fn MQTTAsync_subscribeMany(
        handle: MQTTAsync,
        count: ::std::os::raw::c_int,
        topic: *const *mut ::std::os::raw::c_char,
        qos: *const ::std::os::raw::c_int,
        response: *mut MQTTAsync_responseOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function attempts to remove an existing subscription made by the"]
    #[doc = " specified client."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @param topic The topic for the subscription to be removed, which may"]
    #[doc = " include wildcards (see @ref wildcard)."]
    #[doc = " @param response A pointer to a response options structure. Used to set callback functions."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the subscription is removed."]
    #[doc = " An error code is returned if there was a problem removing the"]
    #[doc = " subscription."]
    pub fn MQTTAsync_unsubscribe(
        handle: MQTTAsync,
        topic: *const ::std::os::raw::c_char,
        response: *mut MQTTAsync_responseOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function attempts to remove existing subscriptions to a list of topics"]
    #[doc = " made by the specified client."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @param count The number subscriptions to be removed."]
    #[doc = " @param topic An array (of length <i>count</i>) of pointers to the topics of"]
    #[doc = " the subscriptions to be removed, each of which may include wildcards."]
    #[doc = " @param response A pointer to a response options structure. Used to set callback functions."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the subscriptions are removed."]
    #[doc = " An error code is returned if there was a problem removing the subscriptions."]
    pub fn MQTTAsync_unsubscribeMany(
        handle: MQTTAsync,
        count: ::std::os::raw::c_int,
        topic: *const *mut ::std::os::raw::c_char,
        response: *mut MQTTAsync_responseOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function attempts to publish a message to a given topic (see also"]
    #[doc = " ::MQTTAsync_sendMessage()). An ::MQTTAsync_token is issued when"]
    #[doc = " this function returns successfully if the QoS is greater than 0."]
    #[doc = " If the client application needs to"]
    #[doc = " test for successful delivery of messages, a callback should be set"]
    #[doc = " (see ::MQTTAsync_onSuccess() and ::MQTTAsync_deliveryComplete())."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @param destinationName The topic associated with this message."]
    #[doc = " @param payloadlen The length of the payload in bytes."]
    #[doc = " @param payload A pointer to the byte array payload of the message."]
    #[doc = " @param qos The @ref qos of the message."]
    #[doc = " @param retained The retained flag for the message."]
    #[doc = " @param response A pointer to an ::MQTTAsync_responseOptions structure. Used to set callback functions."]
    #[doc = " This is optional and can be set to NULL."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the message is accepted for publication."]
    #[doc = " An error code is returned if there was a problem accepting the message."]
    pub fn MQTTAsync_send(
        handle: MQTTAsync,
        destinationName: *const ::std::os::raw::c_char,
        payloadlen: ::std::os::raw::c_int,
        payload: *const ::std::os::raw::c_void,
        qos: ::std::os::raw::c_int,
        retained: ::std::os::raw::c_int,
        response: *mut MQTTAsync_responseOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function attempts to publish a message to a given topic (see also"]
    #[doc = " MQTTAsync_publish()). An ::MQTTAsync_token is issued when"]
    #[doc = " this function returns successfully if the QoS is greater than 0."]
    #[doc = " If the client application needs to"]
    #[doc = " test for successful delivery of messages, a callback should be set"]
    #[doc = " (see ::MQTTAsync_onSuccess() and ::MQTTAsync_deliveryComplete())."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @param destinationName The topic associated with this message."]
    #[doc = " @param msg A pointer to a valid MQTTAsync_message structure containing"]
    #[doc = " the payload and attributes of the message to be published."]
    #[doc = " @param response A pointer to an ::MQTTAsync_responseOptions structure. Used to set callback functions."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the message is accepted for publication."]
    #[doc = " An error code is returned if there was a problem accepting the message."]
    pub fn MQTTAsync_sendMessage(
        handle: MQTTAsync,
        destinationName: *const ::std::os::raw::c_char,
        msg: *const MQTTAsync_message,
        response: *mut MQTTAsync_responseOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function sets a pointer to an array of tokens for"]
    #[doc = " messages that are currently in-flight (pending completion)."]
    #[doc = ""]
    #[doc = " <b>Important note:</b> The memory used to hold the array of tokens is"]
    #[doc = " malloc()'d in this function. The client application is responsible for"]
    #[doc = " freeing this memory when it is no longer required."]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @param tokens The address of a pointer to an ::MQTTAsync_token."]
    #[doc = " When the function returns successfully, the pointer is set to point to an"]
    #[doc = " array of tokens representing messages pending completion. The last member of"]
    #[doc = " the array is set to -1 to indicate there are no more tokens. If no tokens"]
    #[doc = " are pending, the pointer is set to NULL."]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the function returns successfully."]
    #[doc = " An error code is returned if there was a problem obtaining the list of"]
    #[doc = " pending tokens."]
    pub fn MQTTAsync_getPendingTokens(
        handle: MQTTAsync,
        tokens: *mut *mut MQTTAsync_token,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MQTTAsync_isComplete(handle: MQTTAsync, token: MQTTAsync_token)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits for a request corresponding to a token to complete.  This only works for"]
    #[doc = " messages with QoS greater than 0.  A QoS 0 message has no MQTT token."]
    #[doc = " This function will always return ::MQTTASYNC_SUCCESS for a QoS 0 message."]
    #[doc = ""]
    #[doc = " @param handle A valid client handle from a successful call to"]
    #[doc = " MQTTAsync_create()."]
    #[doc = " @param token An ::MQTTAsync_token associated with a request."]
    #[doc = " @param timeout the maximum time to wait for completion, in milliseconds"]
    #[doc = " @return ::MQTTASYNC_SUCCESS if the request has been completed in the time allocated,"]
    #[doc = "  ::MQTTASYNC_FAILURE or ::MQTTASYNC_DISCONNECTED if not."]
    pub fn MQTTAsync_waitForCompletion(
        handle: MQTTAsync,
        token: MQTTAsync_token,
        timeout: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function frees memory allocated to an MQTT message, including the"]
    #[doc = " additional memory allocated to the message payload. The client application"]
    #[doc = " calls this function when the message has been fully processed. <b>Important"]
    #[doc = " note:</b> This function does not free the memory allocated to a message"]
    #[doc = " topic string. It is the responsibility of the client application to free"]
    #[doc = " this memory using the MQTTAsync_free() library function."]
    #[doc = " @param msg The address of a pointer to the ::MQTTAsync_message structure"]
    #[doc = " to be freed."]
    pub fn MQTTAsync_freeMessage(msg: *mut *mut MQTTAsync_message);
}
extern "C" {
    #[doc = " This function frees memory allocated by the MQTT C client library, especially the"]
    #[doc = " topic name. This is needed on Windows when the client library and application"]
    #[doc = " program have been compiled with different versions of the C compiler.  It is"]
    #[doc = " thus good policy to always use this function when freeing any MQTT C client-"]
    #[doc = " allocated memory."]
    #[doc = " @param ptr The pointer to the client library storage to be freed."]
    pub fn MQTTAsync_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " This function is used to allocate memory to be used or freed by the MQTT C client library,"]
    #[doc = " especially the data in the ::MQTTPersistence_afterRead and ::MQTTPersistence_beforeWrite"]
    #[doc = " callbacks. This is needed on Windows when the client library and application"]
    #[doc = " program have been compiled with different versions of the C compiler."]
    #[doc = " @param size The size of the memory to be allocated."]
    pub fn MQTTAsync_malloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " This function frees the memory allocated to an MQTT client (see"]
    #[doc = " MQTTAsync_create()). It should be called when the client is no longer"]
    #[doc = " required."]
    #[doc = " @param handle A pointer to the handle referring to the ::MQTTAsync"]
    #[doc = " structure to be freed."]
    pub fn MQTTAsync_destroy(handle: *mut MQTTAsync);
}
pub const MQTTASYNC_TRACE_LEVELS_MQTTASYNC_TRACE_MAXIMUM: MQTTASYNC_TRACE_LEVELS = 1;
pub const MQTTASYNC_TRACE_LEVELS_MQTTASYNC_TRACE_MEDIUM: MQTTASYNC_TRACE_LEVELS = 2;
pub const MQTTASYNC_TRACE_LEVELS_MQTTASYNC_TRACE_MINIMUM: MQTTASYNC_TRACE_LEVELS = 3;
pub const MQTTASYNC_TRACE_LEVELS_MQTTASYNC_TRACE_PROTOCOL: MQTTASYNC_TRACE_LEVELS = 4;
pub const MQTTASYNC_TRACE_LEVELS_MQTTASYNC_TRACE_ERROR: MQTTASYNC_TRACE_LEVELS = 5;
pub const MQTTASYNC_TRACE_LEVELS_MQTTASYNC_TRACE_SEVERE: MQTTASYNC_TRACE_LEVELS = 6;
pub const MQTTASYNC_TRACE_LEVELS_MQTTASYNC_TRACE_FATAL: MQTTASYNC_TRACE_LEVELS = 7;
pub type MQTTASYNC_TRACE_LEVELS = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This function sets the level of trace information which will be"]
    #[doc = " returned in the trace callback."]
    #[doc = " @param level the trace level required"]
    pub fn MQTTAsync_setTraceLevel(level: MQTTASYNC_TRACE_LEVELS);
}
#[doc = " This is a callback function prototype which must be implemented if you want"]
#[doc = " to receive trace information."]
#[doc = " @param level the trace level of the message returned"]
#[doc = " @param message the trace message.  This is a pointer to a static buffer which"]
#[doc = " will be overwritten on each call.  You must copy the data if you want to keep"]
#[doc = " it for later."]
pub type MQTTAsync_traceCallback = ::std::option::Option<
    unsafe extern "C" fn(level: MQTTASYNC_TRACE_LEVELS, message: *mut ::std::os::raw::c_char),
>;
extern "C" {
    #[doc = " This function sets the trace callback if needed.  If set to NULL,"]
    #[doc = " no trace information will be returned.  The default trace level is"]
    #[doc = " MQTTASYNC_TRACE_MINIMUM."]
    #[doc = " @param callback a pointer to the function which will handle the trace information"]
    pub fn MQTTAsync_setTraceCallback(callback: MQTTAsync_traceCallback);
}
extern "C" {
    #[doc = " This function returns version information about the library."]
    #[doc = " no trace information will be returned.  The default trace level is"]
    #[doc = " MQTTASYNC_TRACE_MINIMUM"]
    #[doc = " @return an array of strings describing the library.  The last entry is a NULL pointer."]
    pub fn MQTTAsync_getVersionInfo() -> *mut MQTTAsync_nameValue;
}
extern "C" {
    #[doc = " Returns a pointer to a string representation of the error code, or NULL."]
    #[doc = " Do not free after use. Returns NULL if the error code is unknown."]
    #[doc = " @param code the MQTTASYNC_ return code."]
    #[doc = " @return a static string representation of the error code."]
    pub fn MQTTAsync_strerror(code: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
